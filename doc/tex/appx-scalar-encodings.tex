
\newpage
\section{Instruction Encodings}

This section describes the encodings for the {\em Scalar} Cryptography
extension.
It is developed in accordance with the RISC-V Instruction Encodings
Allocation Policy~\cite{riscv:policy:encodings}.
Listed below are the evaluation criteria for the proposed encodings.
Some of these are re-statements of the obvious, some are re-statements of
the Allocation Policy document, and some are added to acknowledge the
nature of the instructions being proposed.

\begin{enumerate}
\item \label{itm:enc:1}
The total number of encoding points used will be minimised.
\item \label{itm:enc:2}
The size of the decoder logic generally will be minimised.
\item \label{itm:enc:3}
All instructions will re-use existing encoding formats where
appropriate. Where an instruction does not exactly fit an existing format,
the closest format will be used, with arguments as to why that format is
best.
\item \label{itm:enc:4}
The complexity of {\em rejecting} invalid instructions must be balanced with
the complexity of identifying {\em valid} instructions.
\item \label{itm:enc:5}
Where a particular design choice has been made, rationale will be provided
and other rejected options will be described.
Where the design choice is somewhat arbitrary (at-least to the designers
knowledge) this too will be noted.
\item \label{itm:enc:6}
Where instructions are exclusive to a particular base architecture
(i.e. used on RV32 / RV64 only), these encodings will be overlapped with
{\em other} instructions which are exclusive to a {\em different base
architecture}. This allows the base architecture to act as an additional
implicit bit in the encoding, thus saving actual encoding space.
\item \label{itm:enc:7}
New encoding constraints such as relationships between register addresses
will be {\em sufficient but not necessary} to uniquely decode all of
the instructions.
This allows for additional saving of encoding space {\em if and only if}
the additional complexity and costs are deemed worth while.
\end{enumerate}

\subsection{Decoding Strategy}

Scalar Cryptography instructions which write a single
destination register, and read two source registers
best fit in the {\tt OP} major opcode, which contains other ALU-esq
instructions which source two registers.
Scalar Cryptography instructions which source a single register ({\tt rs1})
best fit into the {\tt OP-IMM} major opcode.
Even instructions with only a single source register and no immediate are
better placed in the {\tt OP-IMM} space, because the decoder will already
have inferred that only a single register needs reading, and can disregard
the {\tt rs2} field.

The encodings for the Scalar Cryptography instructions are chosen based on
two assumptions.
First, the instruction implementations share little or no logic with existing
RISC-V instructions, and so can be expected to be implemented
independently.
Second, it will be reasonable to implement all of the Scalar Cryptography
instructions as part of the same {\em functional unit} within the
execution pipeline of a core.

Based on these two assumptions, we want to:
very quickly identify
that we are decoding {\em any} Scalar Cryptography instruction, in order to
select the correct functional unit to send it too; and
easily identify {\em which} Scalar Cryptography instruction we are decoding,
so that it may be identified and executed with minimal effort by the
functional unit.

Scalar Cryptography instructions all use {\tt func3=0b000},
and {\tt bit[28]=1}, with either the {\tt OP} or {\tt OP-IMM} major opcode.
This places them adjacent to the {\tt add/mul/sub} instructions in {\tt OP},
or the {\tt slli/fsgnj.q} instructions in {\tt OP-IMM} 
but distinguished always by bit $28$.
Logic for identifying each of these sub-field values already exists, so
the cost of separating all Scalar Crypto instructions from the rest of the
ISA is of the order of three 2-input AND gates and a 2-input OR gate.

Individual instructions within the Scalar Cryptography extension
are then interpreted based on the {\tt func7} and {\tt rs2/shamt} bitfields.

All instructions with a single register operand can be distinguished
with {\tt func7=0b0001000}.
The {\tt rs2} field is then used to encode the exact kind of instruction.
Although this means that an instruction which does not read {\tt rs2} has
a non-zero {\tt rs2} field (which might be inefficient or cause un-wanted
register toggling in non-gated designs),
it is more efficient in terms of opcode-space to re-use the {\tt rs2} field
for encoding bits, and
so leave additional {\tt func7} encodings free for more instructions which
use two source registers.

For single operand SHA instructions,
bit $22$ distinguishes SHA256 and SHA512, while
bits $21:20$ distinguish between
{\tt sum0},
{\tt sum1},
{\tt sig0},
and
{\tt sig1}.
For the RV32-only SHA512 instructions,
bits $26:25$ distinguish between {\tt sig/sum} and {\tt 0/1},
while bit $27$ distinguishes high/low variants of the {\tt sha512sig*}
instructions.
Having the operation bits for SHA512/SHA256 instructions at a different place
in the instruction on RV32 is slightly inefficient and costs more gates,
but is much more efficient in terms of opcode space.
All encodings taken up by {\tt sha512*} instructions on RV32 and
free for use by other instructions on RV64.

Bit $28$ distinguishes between hash function instructions and block
cipher instructions.
Bit $25$ distinguish between SM4 and AES Block ciphers.

All AES round instructions use bits $27:26$ to distinguish between
encrypt/decrypt and middle/final round variants.
On RV64, the \mnemonic{aes64ks2} and \mnemonic{aes64im} instructions
are distinguished by checking if
{\tt rs2=0} (\mnemonic{aes64im}) or not (\mnemonic{aes64ks2}).
Note that this breaks point \ref{itm:enc:7} above, but can easily be
fixed by moving \mnemonic{aes64im} to the {\tt OP-IMM} major opcode
if the register address comparison is deemed un-reasonable.

For the SM4 and RV32 AES instructions, we require that {\tt rs1=rd}.
Encodings where {\tt rs1!=rd} raise an Illegal Opcode Exception unless
they are defined as another instruction by another extension, or
future versions of the Scalar Cryptography Extension.
This reflects the fact that these instructions are designed to {\em always}
use their source/destination registers in this way.
This takes the number of encoding points used per RV32 AES / SM4 instruction
from $131072$ to $4096$.
It is possible to {\em remove} the {\tt rd} field completely from these
instructions and say that {\tt rd} must be sourced from the {\tt rs1}
field.
This breaks existing encoding idioms however about register address fields
always being in the same place in the encoding.

\todo{Discuss rejecting invalid instructions.}
\todo{Encoding point counts for each instruction.}

\clearpage
\subsection{Instruction Encodings Table: RV32}

\begin{bytefield}[bitwidth={1.05em},endianness={big}]{32}
\bitheader{0-31} \\
\encpollentropy
\encgetnoise
\encsmthreepzero
\encsmthreepone
\encshatwofivesixsumzero
\encshatwofivesixsumone
\encshatwofivesixsigzero
\encshatwofivesixsigone
\encshafiveonetwosumzeror
\encshafiveonetwosumoner
\encshafiveonetwosigzerol
\encshafiveonetwosigzeroh
\encshafiveonetwosigonel
\encshafiveonetwosigoneh
\encsmfoured
\encsmfourks
\encaesthreetwoesmi
\encaesthreetwoesi
\encaesthreetwodsmi
\encaesthreetwodsi
\end{bytefield}

\clearpage
\subsection{Instruction Encodings Table: RV64}

\begin{bytefield}[bitwidth={1.05em},endianness={big}]{32}
\bitheader{0-31} \\
\encpollentropy
\encgetnoise
\encsmfoured
\encsmfourks
\encsmthreepzero
\encsmthreepone
\encshatwofivesixsumzero
\encshatwofivesixsumone
\encshatwofivesixsigzero
\encshatwofivesixsigone
\encshafiveonetwosumzero
\encshafiveonetwosumone
\encshafiveonetwosigzero
\encshafiveonetwosigone
\encaessixfourksonei
\encaessixfourkstwo
\encaessixfourim
\encaessixfouresm
\encaessixfoures
\encaessixfourdsm
\encaessixfourds
\end{bytefield}
