
\newpage
\section{Instruction Encodings}

This section describes the encodings for the {\em Scalar} Cryptography
extension.
It is developed in accordance with the RISC-V Instruction Encodings
Allocation Policy~\cite{riscv:policy:encodings}.
Listed below are the evaluation critera for the proposed encodings.
Some of these are re-statements of the obvious, some are re-statements of
the Allocation Policy document, and some are added to acknowledge the
nature of the instructions being proposed.

\begin{enumerate}
\item \label{itm:enc:1}
The total number of encoding points used will be minimised.
\item \label{itm:enc:2}
The size of the decoder logic generally will be minimised.
\item \label{itm:enc:3}
All instructions will re-use existing encoding formats where
appropriate. Where an instruction does not exactly fit an existing format,
the closest format will be used, with arguments as to why that format is
best.
\item \label{itm:enc:4}
The complexity of {\em rejecting} invalid instructions must be balanced with
the complexity of identifying {\em valid} instructions.
\item \label{itm:enc:5}
Where a particular design choice has been made, rationale will be provided
and other rejected options will be described.
Where the design choice is somewhat arbitrary (at-least to the designers
knowledge) this too will be noted.
\item \label{itm:enc:6}
Where instructions are exclusive to a particular base architecture
(i.e. used on RV32 / RV64 only), these encodings will be overlapped with
{\em other} instructions which are exclusive to a {\em different base
architecture}. This allows the base architecture to act as an additional
implicit bit in the encoding, thus saving actual encoding space.
\item \label{itm:enc:7}
New encoding constraints such as relationships between register addresses
will be {\em sufficient but not neccessary} to uniquely decode all of
the instructions.
This allows for additional saving of encoding space {\em if and only if}
the additional complexity and costs are deemed worth while.
\end{enumerate}

\subsection{Decoding Strategy}

Almost all of the Scalar Cryptography instructions write a single
destination register, and read one or two source registers, meaning they
best fit in the {\tt OP} major opcode.
The single exception is \mnemonic{aes64ks1i}, which has one source register
and one 4-bit immediate, and so best sits in the {\tt OP-IMM} major opcode
along with instructions like \mnemonic{slli}.

The encodings for the Scalar Cryptography instructions are chosen based on
two assumptions.
First, the instruction implementations share little or no logic with existing
RISC-V instructions, and so can be expected to be implemented
independantly.
Second, it will be reasonable to implement all of the Scalar Cryptography
instructions as part of the same {\em functional unit} within the
execution pipeline of a core.

Based on these two assumptions, we want to:
Very quickly identify
that we are decoding {\em any} Scalar Cryptography instruction, in order to
select the correct functional unit to send it too; and
easily identify {\em which} Scalar Cryptography instruction we are decoding,
so that it may be identifed and executed with minimal effort by the
functional unit.

Scalar Cryptography instructions are first divided into Hash Function
instructions (\mnemonic{sha256*},\mnemonic{sha512*},\mnemonic{sm3*})
and Block Cipher instructions
(\mnemonic{aes*}, \mnemonic{sm4*}).
\begin{enumerate}
\item Hash Function instructions use {\tt func3=0b010},
\item Block Cipher instructions  use {\tt func3=0b000}.
\end{enumerate}
This places
Hash Function instructions adjacent to \mnemonic{slt/mulhsu/clmulr/sh1add}
and
Block Cipher instructions adjacent to \mnemonic{add/sub/mul}.
In both cases, Scalar Cryptography instructions are distinguished from
existing ALU-type instructions by checking if bit $28$ is {\em set}.

Hence, we end up with the following rules for quickly identifying
Scalar Cryptography instructions:
\begin{enumerate}
\item Hash Function instructions: {\tt func3=0b010, opcode=0b0110011, bit[28]=1}
\item Block Cipher  instructions: {\tt func3=0b000, opcode=0b0110011, bit[28]=1}
\end{enumerate}

\noindent
The single exception to this is \mnemonic{aes64ks1i}, which has
{\tt opcode=0b0{\bf 0}1011}.

All instructions with a single register operand can be distinguished
with {\tt func7=0b0001000}.
The {\tt rs2} field is then used to encode the exact kind of instruction.
Although this means that an instruction which does not read {\tt rs2} has
a non-zero {\tt rs2} field (which might be inefficient or cause un-wanted
register toggling in non-gated designs),
it is more efficient in terms of opcode-space to re-use the {\tt rs2} field
for encoding bits, and
so leave additional {\tt func7} encodings free for more instructions which
use two source registers.

For single operand SHA instructions,
bit $22$ distinguishes SHA256 and SHA512, while
bits $21:20$ distinguish between
{\tt sum0},
{\tt sum1},
{\tt sig0},
and
{\tt sig1}.
For the RV32-only SHA512 instructions,
bits $26:25$ distinguish between {\tt sig/sum} and {\tt 0/1},
while bit $27$ distinguishes high/low variants of the {\tt sha512sig*}
instructions.
Having the operation bits for SHA512/SHA256 instructions at a different place
in the instruction on RV32 is slightly inefficient and costs more gates,
but is much more efficient in terms of opcode space.
All encodings taken up by {\tt sha512*} instructions on RV32 and
free for use by other instructions on RV64.

All AES round instructions use bits $27:26$ to distinguish between
encrypt/decrypt and middle/final round variants.
On RV64, the \mnemonic{aes64ks2} and \mnemonic{aes64im} instructions
are distinguished by checking if
{\tt rs2=0} (\mnemonic{aes64im}) or not (\mnemonic{aes64ks2}).
Note that this breaks point \ref{itm:enc:7} above, but can easily be
fixed if the register address comparison is deemed un-reasonable.

For the SM4 and RV32 AES instructions, we require that {\tt rs1=rd}.
Encodings where {\tt rs1!=rd} raise an Illegal Opcode Exception unless
they are defined as another instruction by another extension, or
future versions of the Scalar Cryptography Extension.
This reflects the fact that these instructions are designed to {\em always}
use their source/destination registers in this way.
This takes the number of encoding points used per RV32 AES / SM4 instruction
from $131072$ to $4096$.
It is possible to {\em remove} the {\tt rd} field completed from these
instructions and say that {\tt rd} must be sourced from the {\tt rs1}
field.
This breaks existing encoding idioms however about register address fields
always being in the same place in the encoding.

\clearpage
\subsection{Instruction Encodings Table: RV32}

\begin{bytefield}[bitwidth={1.05em},endianness={big}]{32}
\bitheader{0-31} \\
\encpollentropy
\encgetnoise
\encsmthreepzero
\encsmthreepone
\encshatwofivesixsumzero
\encshatwofivesixsumone
\encshatwofivesixsigzero
\encshatwofivesixsigone
\encshafiveonetwosumzeror
\encshafiveonetwosumoner
\encshafiveonetwosigzerol
\encshafiveonetwosigzeroh
\encshafiveonetwosigonel
\encshafiveonetwosigoneh
\encsmfoured
\encsmfourks
\encaesthreetwoesmi
\encaesthreetwoesi
\encaesthreetwodsmi
\encaesthreetwodsi
\end{bytefield}

\clearpage
\subsection{Instruction Encodings Table: RV64}

\begin{bytefield}[bitwidth={1.05em},endianness={big}]{32}
\bitheader{0-31} \\
\encpollentropy
\encgetnoise
\encsmfoured
\encsmfourks
\encsmthreepzero
\encsmthreepone
\encshatwofivesixsumzero
\encshatwofivesixsumone
\encshatwofivesixsigzero
\encshatwofivesixsigone
\encshafiveonetwosumzero
\encshafiveonetwosumone
\encshafiveonetwosigzero
\encshafiveonetwosigone
\encaessixfourksonei
\encaessixfourkstwo
\encaessixfourim
\encaessixfouresm
\encaessixfoures
\encaessixfourdsm
\encaessixfourds
\end{bytefield}
