
\newpage
\subsection{Lightweight AES Acceleration}

This section details $3.5$ proposals for lightweight acceleration of
the AES block cipher \cite{nist:fips:197}.

Performance and RTL benchmarks for these
instruction proposals are found in Section
\ref{sec:benchmark:aes}.

% ------------------------------------------------------------

\subsubsection{Variant 1}

\begin{cryptoisa}
RV32, RV64:
    saes.v1.enc rd, rs1
    saes.v1.dec rd, rs1
\end{cryptoisa}

These instructions implement the 
{\tt SubBytes} \cite[Section 5.1.1]{nist:fips:197}
and
{\tt InvSubBytes} \cite[Section 5.3.1]{nist:fips:197}
steps of the AES Block Cipher \cite{nist:fips:197}.
The low 32-bits of {\tt rs1} are split into bytes.
Each byte has the relevant transformation applied, before
being written back to the corresponding byte position in {\tt rd}.
On an RV64 platform, the high 32-bits of the result are zero
extended.
Pseudo code is found in figure
\ref{fig:pseudo:aes:v1}.

This proposal variant requires $2$ encoding points with only one
source register.

\begin{figure}
\begin{subfigure}[b]{0.5\textwidth}
\begin{lstlisting}
saes.v1.enc(rs1):
    rd.8[0] =    AESSBox(rs1.8[0])
    rd.8[1] =    AESSBox(rs1.8[1])
    rd.8[2] =    AESSBox(rs1.8[2])
    rd.8[3] =    AESSBox(rs1.8[3])
\end{lstlisting}
\caption{Forward SBox instruction pseudo code.}
\label{fig:pseudo:aes:v1:sub:enc}
\end{subfigure}
\begin{subfigure}[b]{0.5\textwidth}
\begin{lstlisting}
saes.v1.dec(rs1):
    rd.8[0] = InvAESSBox(rs1.8[0])
    rd.8[1] = InvAESSBox(rs1.8[1])
    rd.8[2] = InvAESSBox(rs1.8[2])
    rd.8[3] = InvAESSBox(rs1.8[3])
\end{lstlisting}
\label{fig:pseudo:aes:v1:sub:dec}
\caption{Inverse SBox instruction pseudo code.}
\end{subfigure}
\caption{AES Instructions variant 1.}
\label{fig:pseudo:aes:v1}.
\end{figure}

% ------------------------------------------------------------

\subsubsection{Variant 2}

\begin{cryptoisa}
RV32, RV64:
    saes.v2.sub.enc    rd, rs1, rs2
    saes.v2.sub.dec    rd, rs1, rs2
    saes.v2.mix.enc    rd, rs1, rs2
    saes.v2.mix.dec    rd, rs1, rs2
\end{cryptoisa}

These instructions are derived from \cite{MPP:19}, which in turn adapted
them originally from \cite{TG:06}.
Each instruction performs either the SubBytes or MixColumns transformation
to a single column of the AES state, along with a partial ShiftRows.
Example usage can be found in the riscv-crypto repository
\footnote{\url{https://github.com/scarv/riscv-crypto/blob/master/benchmarks/crypto_block/aes/zscrypto_v2/aes_enc.c\#L53}}.

Pseudo-code for the sub-bytes and mix-columns instructions are found in
figures
\ref{fig:pesudo:aes:v2:sub}
and
\ref{fig:pesudo:aes:v2:mix}
respectively.

This proposal variant requires $4$ encoding points, where each point
requires two source registers and a destination register.

\begin{figure}
\begin{subfigure}[b]{1.0\textwidth}
\begin{lstlisting}
saes.v2.sub(rs1, rs2, mode):
    if(mode == enc)
        t0 =    AESSBox(rs1.8[0]), t1 =    AESSBox(rs2.8[1])
        t2 =    AESSBox(rs1.8[2]), t3 =    AESSBox(rs2.8[3])
    else
        t0 = InvAESSBox(rs1.8[0]), t1 = InvAESSBox(rs2.8[1])
        t2 = InvAESSBox(rs1.8[2]), t3 = InvAESSBox(rs2.8[3])
    rd.32 = {t3, t2, t1, t0} 
\end{lstlisting}
\caption{AES instruction variant 2: sbox instruction pseudo code.}
\label{fig:pesudo:aes:v2:sub}
\end{subfigure}
\begin{subfigure}[b]{1.0\textwidth}
\begin{lstlisting}
saes.v2.mix(rs1, rs2, mode):
    t0 = rs1.8[0], t1 = rs1.8[1]
    t2 = rs2.8[2], t3 = rs2.8[3]
    if(mode == enc)
        rd.32 =    AESMixColumns(t3,t2,t1,t0)
    else
        rd.32 = InvAESMixColumns(t3,t2,t1,t0)
\end{lstlisting}
\caption{AES instruction variant 2: Mix columns instruction pseudo code.}
\label{fig:pesudo:aes:v2:mix}
\end{subfigure}
\caption{AES Instructions: Variant 2 Pseudo Code.}
\end{figure}

% ------------------------------------------------------------

\subsubsection{Variant 3}

\begin{cryptoisa}
RV32, RV64:
    saes.v3.encs      rd, rs1, rs2, bs // Encrypt: SubBytes
    saes.v3.encm      rd, rs1, rs2, bs // Encrypt: MixColumns
    saes.v3.encsm     rd, rs1, rs2, bs // Encrypt: SubBytes & MixColumns
    saes.v3.decs      rd, rs1, rs2, bs // Decrypt: SubBytes
    saes.v3.decm      rd, rs1, rs2, bs // Decrypt: MixColumns
    saes.v3.decsm     rd, rs1, rs2, bs // Decrypt: SubBytes & MixColumns
\end{cryptoisa}

These instructions are a very lightweight proposal, derived from
\cite{MJS:20}.
They are designed to enable a partial T-Table based implementation
of AES in hardware, where the SubBytes, ShiftRows and MixColumns
transformations are all rolled into a single instruction, with the
per-byte results then accumulated.
The {\tt bs} immediate operand is a 2-bit {\em Byte Select}, and indicates
which byte of the input word is operated on.
In contrast to variants 1 and 2, they perform only a single (Inverse) SBox
lookup per instruction.
Pseudo-code for each instruction is found in figure
\ref{fig:pseudo:aes:v3}.

Only $4$ of the $6$ instructions are strictly needed: one of the following two
subsets would suffice:
\begin{enumerate}
\item[{\bf v3.1:}]  \mnemonic{saes.v3.encs},
                    \mnemonic{saes.v3.encsm},
                    \mnemonic{saes.v3.decs} and
                    \mnemonic{saes.v3.decsm}.
    This set is more performant in terms of instructions executed per
    round.
    It also places the SubBytes and MixColumns operations
    sequentially, and so has a longer timing path.
\item[{\bf v3.2:}]  \mnemonic{saes.v3.encs},
                    \mnemonic{saes.v3.encm},
                    \mnemonic{saes.v3.decs} and
                    \mnemonic{saes.v3.decm}.
    This set splits the SubBytes and MixColumns operations into separate
    instructions.
    This means more instructions per round, but a shorter critical
    timing path for the instruction.
\end{enumerate}

Both the v3.1 and V3.2 proposal variants require $4$ fixed encoding
points with two source registers, one destination register and
a single $2$-bit immediate.
This makes for a total of $16$ encoding points.

\begin{figure}
\begin{subfigure}[b]{1.0\textwidth}
\begin{lstlisting}
saes.v3.encs(rs1, rs2, bs):                 // SubBytes Only
    t0.8  = rs1.8[bs]
    x.8   = AESSBox(t0)
    u.32  = {0, 0, 0, x}
    rd.32 = ROTL32(u, 8*bs) ^ rs2.32

saes.v3.encm(rs1, rs2, bs):                 // MixColumns only
    x.8   = rs1.8[bs]
    u.32  = {GFMUL(x,3) , x, x, GFMUL(x,2)}
    rd.32 = ROTL32(u, 8*bs) ^ rs2.32

saes.v3.encsm(rs1, rs2, bs):                // SubBytes & MixColumns
    t0.8  = rs1.8[bs]
    x.8   = AESSBox(t0)
    u.32  = {GFMUL(x,3) , x, x, GFMUL(x,2)}
    rd.32 = ROTL32(u, 8*bs) ^ rs2.32
\end{lstlisting}
\caption{Encrypt instruction pseudo code.}
\label{fig:pesudo:aes:v3:enc}
\end{subfigure}

\begin{subfigure}[b]{1.0\textwidth}
\begin{lstlisting}
saes.v3.decs(rs1, rs2, bs):                 // InvSubBytes Only
    t0.8  = rs1.8[bs]
    x.8   = InvAESSBox(t0)
    u.32  = {0, 0, 0, x}
    rd.32 = ROTL32(u, 8*bs) ^ rs2.32

saes.v3.decm(rs1, rs2, bs):                 // InvMixColumns Only
    x.8   = rs1.8[bs]
    u.32  = {GFMUL(x,11),GFMUL(x,13),GFMUL(9),GFMUL(14)}
    rd.32 = ROTL32(u, 8*bs) ^ rs2.32

saes.v3.decsm(rs1, rs2, bs):                // InvSubBytes & InvMixColumns
    t0.8  = rs1.8[bs]
    x.8   = InvAESSBox(t0)
    u.32  = {GFMUL(x,11),GFMUL(x,13),GFMUL(9),GFMUL(14)}
    rd.32 = ROTL32(u, 8*bs) ^ rs2.32
\end{lstlisting}
\caption{Decrypt instruction pseudo code.}
\label{fig:pesudo:aes:v3:dec}
\end{subfigure}
\caption{AES instruction variant 3.}
\label{fig:pseudo:aes:v3}
\end{figure}

