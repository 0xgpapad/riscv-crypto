
\newpage
\subsection{Lightweight AES Acceleration}

This section details $3.5$ proposals for lightweight acceleration of
the AES block cipher \cite{nist:fips:197}.

Performance and RTL benchmarks for these
instruction proposals are found in Section
\ref{sec:benchmark:aes}.

% ------------------------------------------------------------

\subsubsection{Variant 1}

\begin{cryptoisa}
RV32, RV64:
    saes.v1.enc rd, rs1
    saes.v1.dec rd, rs1
\end{cryptoisa}

These instructions implement the 
{\tt SubBytes} \cite[Section 5.1.1]{nist:fips:197}
and
{\tt InvSubBytes} \cite[Section 5.3.1]{nist:fips:197}
steps of the AES Block Cipher \cite{nist:fips:197}.
The low 32-bits of {\tt rs1} are split into bytes.
Each byte has the relevant transformation applied, before
being written back to the corresponding byte position in {\tt rd}.
On an RV64 platform, the high 32-bits of the result are zero
extended.
Pseudo code is found in figure
\ref{fig:pseudo:aes:v1}.

This proposal variant requires $2$ encoding points with only one
source register.

\begin{figure}
\begin{subfigure}[b]{0.5\textwidth}
\begin{lstlisting}
saes.v1.enc(rs1):
    rd.8[0] =    AESSBox(rs1.8[0])
    rd.8[1] =    AESSBox(rs1.8[1])
    rd.8[2] =    AESSBox(rs1.8[2])
    rd.8[3] =    AESSBox(rs1.8[3])
\end{lstlisting}
\caption{Forward SBox instruction pseudo code.}
\label{fig:pseudo:aes:v1:sub:enc}
\end{subfigure}
\begin{subfigure}[b]{0.5\textwidth}
\begin{lstlisting}
saes.v1.dec(rs1):
    rd.8[0] = InvAESSBox(rs1.8[0])
    rd.8[1] = InvAESSBox(rs1.8[1])
    rd.8[2] = InvAESSBox(rs1.8[2])
    rd.8[3] = InvAESSBox(rs1.8[3])
\end{lstlisting}
\label{fig:pseudo:aes:v1:sub:dec}
\caption{Inverse SBox instruction pseudo code.}
\end{subfigure}
\caption{AES Instructions variant 1.}
\label{fig:pseudo:aes:v1}.
\end{figure}

% ------------------------------------------------------------

\subsubsection{Variant 2}

\begin{cryptoisa}
RV32, RV64:
    saes.v2.sub.enc    rd, rs1, rs2
    saes.v2.sub.dec    rd, rs1, rs2
    saes.v2.mix.enc    rd, rs1, rs2
    saes.v2.mix.dec    rd, rs1, rs2
\end{cryptoisa}

These instructions are derived from \cite{MPP:19}, which in turn adapted
them originally from \cite{TG:06}.
Each instruction performs either the SubBytes or MixColumns transformation
to a single column of the AES state, along with a partial ShiftRows.
Example usage can be found in the riscv-crypto repository
\footnote{\url{https://github.com/scarv/riscv-crypto/blob/master/benchmarks/crypto_block/aes/zscrypto_v2/aes_enc.c\#L53}}.

Pseudo-code for the sub-bytes and mix-columns instructions are found in
figures
\ref{fig:pesudo:aes:v2:sub}
and
\ref{fig:pesudo:aes:v2:mix}
respectively.

This proposal variant requires $4$ encoding points, where each point
requires two source registers and a destination register.

\begin{figure}
\begin{subfigure}[b]{1.0\textwidth}
\begin{lstlisting}
saes.v2.sub(rs1, rs2, mode):
    if(mode == enc)
        t0 =    AESSBox(rs1.8[0]), t1 =    AESSBox(rs2.8[1])
        t2 =    AESSBox(rs1.8[2]), t3 =    AESSBox(rs2.8[3])
    else
        t0 = InvAESSBox(rs1.8[0]), t1 = InvAESSBox(rs2.8[1])
        t2 = InvAESSBox(rs1.8[2]), t3 = InvAESSBox(rs2.8[3])
    rd.32 = {t3, t2, t1, t0} 
\end{lstlisting}
\caption{AES instruction variant 2: sbox instruction pseudo code.}
\label{fig:pesudo:aes:v2:sub}
\end{subfigure}
\begin{subfigure}[b]{1.0\textwidth}
\begin{lstlisting}
saes.v2.mix(rs1, rs2, mode):
    t0 = rs1.8[0], t1 = rs1.8[1]
    t2 = rs2.8[2], t3 = rs2.8[3]
    if(mode == enc)
        rd.32 =    AESMixColumns(t3,t2,t1,t0)
    else
        rd.32 = InvAESMixColumns(t3,t2,t1,t0)
\end{lstlisting}
\caption{AES instruction variant 2: Mix columns instruction pseudo code.}
\label{fig:pesudo:aes:v2:mix}
\end{subfigure}
\caption{AES Instructions: Variant 2 Pseudo Code.}
\end{figure}

% ------------------------------------------------------------

\subsubsection{Variant 3}

\begin{cryptoisa}
RV32, RV64:
    saes.v3.encs      rd, rs1, rs2, bs // Encrypt: SubBytes
    saes.v3.encm      rd, rs1, rs2, bs // Encrypt: MixColumns
    saes.v3.encsm     rd, rs1, rs2, bs // Encrypt: SubBytes & MixColumns
    saes.v3.decs      rd, rs1, rs2, bs // Decrypt: SubBytes
    saes.v3.decm      rd, rs1, rs2, bs // Decrypt: MixColumns
    saes.v3.decsm     rd, rs1, rs2, bs // Decrypt: SubBytes & MixColumns
\end{cryptoisa}

These instructions are a very lightweight proposal, derived from
\cite{MJS:20}.
They are designed to enable a partial T-Table based implementation
of AES in hardware, where the SubBytes, ShiftRows and MixColumns
transformations are all rolled into a single instruction, with the
per-byte results then accumulated.
The {\tt bs} immediate operand is a 2-bit {\em Byte Select}, and indicates
which byte of the input word is operated on.
In contrast to variants 1 and 2, they perform only a single (Inverse) SBox
lookup per instruction.
Pseudo-code for each instruction is found in figure
\ref{fig:pseudo:aes:v3}.

Only $4$ of the $6$ instructions are strictly needed: one of the following two
subsets would suffice:
\begin{enumerate}
\item[{\bf v3.1:}]  \mnemonic{saes.v3.encs},
                    \mnemonic{saes.v3.encsm},
                    \mnemonic{saes.v3.decs} and
                    \mnemonic{saes.v3.decsm}.
    This set is more performant in terms of instructions executed per
    round.
    It also places the SubBytes and MixColumns operations
    sequentially, and so has a longer timing path.
\item[{\bf v3.2:}]  \mnemonic{saes.v3.encs},
                    \mnemonic{saes.v3.encm},
                    \mnemonic{saes.v3.decs} and
                    \mnemonic{saes.v3.decm}.
    This set splits the SubBytes and MixColumns operations into separate
    instructions.
    This means more instructions per round, but a shorter critical
    timing path for the instruction.
\end{enumerate}

Both the v3.1 and V3.2 proposal variants require $4$ fixed encoding
points with two source registers, one destination register and
a single $2$-bit immediate.
This makes for a total of $16$ encoding points.

\begin{figure}
\begin{subfigure}[b]{1.0\textwidth}
\begin{lstlisting}
saes.v3.encs(rs1, rs2, bs):                 // SubBytes Only
    t0.8  = rs1.8[bs]
    x.8   = AESSBox(t0)
    u.32  = {0, 0, 0, x}
    rd.32 = ROTL32(u, 8*bs) ^ rs2.32

saes.v3.encm(rs1, rs2, bs):                 // MixColumns only
    x.8   = rs1.8[bs]
    u.32  = {GFMUL(x,3) , x, x, GFMUL(x,2)}
    rd.32 = ROTL32(u, 8*bs) ^ rs2.32

saes.v3.encsm(rs1, rs2, bs):                // SubBytes & MixColumns
    t0.8  = rs1.8[bs]
    x.8   = AESSBox(t0)
    u.32  = {GFMUL(x,3) , x, x, GFMUL(x,2)}
    rd.32 = ROTL32(u, 8*bs) ^ rs2.32
\end{lstlisting}
\caption{Encrypt instruction pseudo code.}
\label{fig:pesudo:aes:v3:enc}
\end{subfigure}

\begin{subfigure}[b]{1.0\textwidth}
\begin{lstlisting}
saes.v3.decs(rs1, rs2, bs):                 // InvSubBytes Only
    t0.8  = rs1.8[bs]
    x.8   = InvAESSBox(t0)
    u.32  = {0, 0, 0, x}
    rd.32 = ROTL32(u, 8*bs) ^ rs2.32

saes.v3.decm(rs1, rs2, bs):                 // InvMixColumns Only
    x.8   = rs1.8[bs]
    u.32  = {GFMUL(x,11),GFMUL(x,13),GFMUL(9),GFMUL(14)}
    rd.32 = ROTL32(u, 8*bs) ^ rs2.32

saes.v3.decsm(rs1, rs2, bs):                // InvSubBytes & InvMixColumns
    t0.8  = rs1.8[bs]
    x.8   = InvAESSBox(t0)
    u.32  = {GFMUL(x,11),GFMUL(x,13),GFMUL(9),GFMUL(14)}
    rd.32 = ROTL32(u, 8*bs) ^ rs2.32
\end{lstlisting}
\caption{Decrypt instruction pseudo code.}
\label{fig:pesudo:aes:v3:dec}
\end{subfigure}
\caption{AES instruction variant 3.}
\label{fig:pseudo:aes:v3}
\end{figure}


% ------------------------------------------------------------

\subsubsection{Variant 4}

\begin{cryptoisa}
RV64:
    saes.v4.sub      rd, rs1
    saes.v4.encsm.lo rd, rs1, rs2
    saes.v4.encsm.hi rd, rs1, rs2
    saes.v4.encs.lo  rd, rs1, rs2
    saes.v4.encs.hi  rd, rs1, rs2

    saes.v4.imix     rd, rs1
    saes.v4.decsm.lo rd, rs1, rs2
    saes.v4.decsm.hi rd, rs1, rs2
    saes.v4.decs.lo  rd, rs1, rs2
    saes.v4.decs.hi  rd, rs1, rs2
\end{cryptoisa}

These instructions are for RV64 only.
They implment an entire round of AES over two instructions.
Each instruction takes two 64-bit registers as input, which represents
the entire 128 bit state of the AES cipher.
The instructions use the equivilent inverse cipher construction
\cite{nist:fips:197}[Page 23, Section 5.3.5].
Hence there are additional instruction specifically for performing the
inverse MixColumns transformation as part of the modified key schedule.
The byte mapping of input register values to AES state and output register
values is shown in figure \ref{fig:aes:v4:mapping}.
Pseudo code for the instructions is found in figure
\ref{fig:pesudo:aes:v4}.

These instructions are designed to be implemented using macro-op fusion or
operand memoisation; meaning that the secondary instruction does not
need to completely re-compute the result
\footnote{
One could design these instructions to have a double-width write-back
mechanism, in which case the hi/lo variants would not be used.
This breaks with the standard RISC two-read-one-write pattern however.
}.
This is similar to the recommended \mnemonic{mulh}, \mnemonic{mul}
sequence in the M extension to compute a full $32*32->64$ bit
multiplication result \cite{riscv:spec:user}[Section 7.1].

\begin{itemize}
\item
The {\tt *.lo} variants compute the first 8 bytes of the next round
state, while the {\tt *.hi} variants compute the last 8 bytes of the
next round state.
\item
The {\tt encsm}/{\tt decsm} instructions perform the (Inverse) SubBytes,
ShiftRows and MixColumns Transformations.
\item
The {\tt encs}/{\tt decs} instructions perform the (Inverse) SubBytes and
ShiftRows Transformations. They are uses for the last round of AES only.
\item
The {\tt sub} instruction applies 8 sboxes to each of the
8 bytes in the source register, and writes them to the corresponding
byte in the destination register.
It is used for the Key Schedule only.
\item
The \mnemonic{imix} instruction applies only the inverse MixColumns
transformation to two columns of the state array, packed into a single
64-bit register.
It is used to create the inverse cipher key schedule, according to
the equivilent inverse cipher construction in
\cite{nist:fips:197}[Page 23, Section 5.3.5].
\end{itemize}

These instructions should take approximately $6$ instructions per round:
$2$ \mnemonic{ld} instructions to load the round key,
$2$ \mnemonic{xor} to add the round key to the current state
and
$2$ of the relevent AES encrypt/decrypt instructions to perform the
    SubBytes, ShiftRows and MixColumns round functions.
This would add up too approximately $80$ instructions per AES-128 block
encryption, including pre/post-amble instructions.

\vspace{1cm}
\begin{figure}

\begin{subfigure}[b]{1.0\textwidth}
\centering
\begin{bytefield}[endianness=big,bitwidth=0.014\linewidth]{64}
\bitheader{0,7,8,15,16,23,24,31,32,39,40,47,48,55,56,63} \\
\bitboxes{8}{{rs2.8[7]}{rs2.8[6]}{rs2.8[5]}{rs2.8[4]}{rs2.8[3]}{rs2.8[2]}{rs2.8[1]}{rs2.8[0]}} \bitbox{8}{{\bf rs2}} \\
\bitboxes{8}{{rs1.8[7]}{rs1.8[6]}{rs1.8[5]}{rs1.8[4]}{rs1.8[3]}{rs1.8[2]}{rs1.8[1]}{rs1.8[0]}} \bitbox{8}{{\bf rs1}}
\end{bytefield}
Input Register Values
\end{subfigure}

\begin{subfigure}[b]{1.0\textwidth}
\vspace{0.5cm}
\centering
\begin{bytefield}[endianness=big,bitwidth=0.02\linewidth]{32}
\bitheader{0,7,8,15,16,23,24,31} \\
\bitboxes{8}{{b0=rs1.8[0]}{b4=rs1.8[4]}{b8 =rs2.8[0]}{b12=rs2.8[4]}} \\
\bitboxes{8}{{b1=rs1.8[1]}{b5=rs1.8[5]}{b9 =rs2.8[1]}{b13=rs2.8[5]}} \\
\bitboxes{8}{{b2=rs1.8[2]}{b6=rs1.8[6]}{b10=rs2.8[2]}{b14=rs2.8[6]}} \\
\bitboxes{8}{{b3=rs1.8[3]}{b7=rs1.8[7]}{b11=rs2.8[3]}{b15=rs2.8[7]}} \\
\end{bytefield} \\
AES State
\end{subfigure}

\begin{subfigure}[b]{1.0\textwidth}
\vspace{0.5cm}
\centering
\begin{bytefield}[endianness=big,bitwidth=0.014\linewidth]{64}
\bitheader{0,7,8,15,16,23,24,31,32,39,40,47,48,55,56,63} \\
\bitboxes{8}{{b15=rd.8[7]}{b14=rd.8[6]}{b13=rd.8[5]}{b12=rd.8[4]}{b11=rd.8[3]}{b10=rd.8[2]}{b9=rd.8[1]}{b8=rd.8[0]}} \bitbox{8}{{\bf rd(hi)}} \\
\bitboxes{8}{{b7 =rd.8[7]}{b6 =rd.8[6]}{b5 =rd.8[5]}{b4 =rd.8[4]}{b3 =rd.8[3]}{b2 =rd.8[2]}{b1=rd.8[1]}{b0=rd.8[0]}} \bitbox{8}{{\bf rd(lo)}}
\end{bytefield}
Output Register Values
\end{subfigure}
\caption{
Mapping of AES State bytes between input and output registers for
AES Variant 4.
}
\label{fig:aes:v4:mapping}
\end{figure}

\begin{figure}
\begin{lstlisting}
saes.v4.sub(rs1):               // SubBytes Only
    rd.8[i]  = AESSBox(rs1.8[i]) for i=0..7

saes.v4.enc(rs1, rs2, mix, hi): // SubBytes, ShiftRows, MixColumns
    tmp.8[i]  = AESSBox(rs1.8[i]) for i=0..7
    tmp.128   = AESShiftRows(tmp.128)
    if(mix):
        tmp.128   = AESMixColumns(tmp.128)
    if(hi):
        rd.64 = tmp.64[1]
    else
        rd.64 = tmp.64[0]

saes.v4.dec(rs1, rs2, mix, hi): // InvSubBytes, InvShiftRows, InvMixColumns
    tmp.8[i]  = InvAESSBox(rs1.8[i]) for i=0..7
    tmp.128   = InvAESShiftRows(tmp.128)
    if(mix):
        tmp.128   = InvAESMixColumns(tmp.128)
    if(hi):
        rd.64 = tmp.64[1]
    else
        rd.64 = tmp.64[0]

saes.v4.imix(rs1):              // Inverse MixColumns
    rd.32[0] = InvAESMixColumns(rs1.32[0])
    rd.32[1] = InvAESMixColumns(rs1.32[1])
\end{lstlisting}
\caption{AES Variant 4 instruction pseudo code.}
\label{fig:pesudo:aes:v4}
\end{figure}

