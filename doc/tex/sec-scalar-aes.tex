
\newpage
\subsection{Lightweight AES Acceleration}

\note{The AES SBox operations are very popular targets for
power or EM based side-channel attacks.
While an instruction like this allows for very efficient AES
implementations, it is very difficult to implement the operation
in a countermeasure friendly way.}

\question{What should the Task Group policy be on enabling
software and/or hardware based side-channel countermeasure?}

\question{Given that enabling and optimising side-channel countermeasures 
is so hard, should the TG focus instead on code-density and performance?
In this case, can implementations with much more structured
inputs (as in \cite{TG:06}) be considered.}

\subsubsection{Variant 1}

\begin{cryptoisa}
RV32, RV64:
    saes.v1.enc rd, rs1
    saes.v1.dec rd, rs1
\end{cryptoisa}

These instructions implement the 
{\tt SubBytes} \cite[Section 5.1.1]{nist:fips:197}
and
{\tt InvSubBytes} \cite[Section 5.3.1]{nist:fips:197}
steps of the AES Block Cipher \cite{nist:fips:197}.
The low 32-bits of {\tt rs1} are split into bytes.
Each byte has the relevant transformation applied, before
being written back to the corresponding byte position in {\tt rd}.
On an RV64 platform, the high 32-bits of the result are zero
extended.
Psueudo code is found in figure
\ref{fig:pseudo:aes:v1}.

\begin{figure}
\begin{subfigure}[b]{0.5\textwidth}
\begin{lstlisting}
saes.v1.enc(rs1):
    rd.8[0] = AESSBox[rs1.8[0]]
    rd.8[1] = AESSBox[rs1.8[1]]
    rd.8[2] = AESSBox[rs1.8[2]]
    rd.8[3] = AESSBox[rs1.8[3]]
\end{lstlisting}
\caption{Forward SBox instruction pseudo code.}
\label{fig:pseudo:aes:v1:sub:enc}
\end{subfigure}
\begin{subfigure}[b]{0.5\textwidth}
\begin{lstlisting}
saes.v1.dec(rs1):
    rd.8[0] = InvAESSBox[rs1.8[0]]
    rd.8[1] = InvAESSBox[rs1.8[1]]
    rd.8[2] = InvAESSBox[rs1.8[2]]
    rd.8[3] = InvAESSBox[rs1.8[3]]
\end{lstlisting}
\label{fig:pseudo:aes:v1:sub:dec}
\caption{Inverse SBox instruction pseudo code.}
\end{subfigure}
\caption{AES Instructions variant 1.}
\label{fig:pseudo:aes:v1}.
\end{figure}

\subsubsection{Variant 2}

\begin{cryptoisa}
RV32, RV64:
    saes.v2.sub.enc    rd, rs1, rs2 // mode = enc, rot = 0
    saes.v2.sub.encrot rd, rs1, rs2 // mode = enc, rot = 1
    saes.v2.sub.dec    rd, rs1, rs2 // mode = dec, rot = 0
    saes.v2.sub.decrot rd, rs1, rs2 // mode = dec, rot = 1

    saes.v2.mix.enc    rd, rs1, rs2 // mode = enc
    saes.v2.mix.dec    rd, rs1, rs2 // mode = dec
\end{cryptoisa}

These instructions are derived from \cite{MPP:19}, which in turn adapted
them originally from \cite{TG:06}.

Pseudo-code for the sub-bytes and mix-columns instructions are found in
figures
\ref{fig:pesudo:aes:v2:sub}
and
\ref{fig:pesudo:aes:v2:mix}
respectivley.

\begin{figure}
\begin{subfigure}[b]{1.0\textwidth}
\begin{lstlisting}
saes.v2.sub(rs1, rs2, mode, rot):
    if(mode == enc)
        t0 =    AESSBox[rs1.8[0]], t1 =    AESSBox[rs2.8[1]]
        t2 =    AESSBox[rs1.8[2]], t3 =    AESSBox[rs2.8[3]]
    else
        t0 = InvAESSBox[rs1.8[0]], t1 = InvAESSBox[rs2.8[1]]
        t2 = InvAESSBox[rs1.8[2]], t3 = InvAESSBox[rs2.8[3]]
    if(rot == 0)
        rd.32 = {t3, t2, t1, t0} 
    else
        rd.32 = {t2, t1, t0, t3}
\end{lstlisting}
\caption{AES instruction variant 2: sbox instruction pseudo code.}
\label{fig:pesudo:aes:v2:sub}
\end{subfigure}
\begin{subfigure}[b]{1.0\textwidth}
\begin{lstlisting}
saes.v2.mix(rs1, rs2, mode):
    t0 = rs1.8[0], t1 = rs1.8[1]
    t2 = rs2.8[2], t3 = rs2.8[3]
    if(mode == enc)
        rd.32 =    AESMixColumns(t3,t2,t1,t0)
    else
        rd.32 = InvAESMixColumns(t3,t2,t1,t0)
\end{lstlisting}
\caption{AES instruction variant 2: Mix columns instruction pseudo code.}
\label{fig:pesudo:aes:v2:mix}
\end{subfigure}
\caption{AES Instructions: Variant 2 Pseudo Code.}
\end{figure}

\subsubsection{Variant 3}

\begin{cryptoisa}
RV32, RV64:
    saes.v3.encs      rd, rs1, rs2, bs // Encrypt: SubBytes
    saes.v3.encm      rd, rs1, rs2, bs // Encrypt: MixColumns
    saes.v3.encsm     rd, rs1, rs2, bs // Encrypt: SubBytes & MixColumns
    saes.v3.decs      rd, rs1, rs2, bs // Decrypt: SubBytes
    saes.v3.decm      rd, rs1, rs2, bs // Decrypt: MixColumns
    saes.v3.decsm     rd, rs1, rs2, bs // Decrypt: SubBytes & MixColumns
\end{cryptoisa}

These instructions are a very lightweight proposal, derived from
\cite{MJS:20}.
They are designed to enable a partial T-Table based implementation
of AES in hardware, where the SubBytes, ShiftRows and MixColumns
transformations are all rolled into a single instruction, with the
per-byte results then accumulated.
In contrast to variants 1 and 2, they perform only a single (Inverse) SBox
lookup per instruction.

Only $4$ of the $6$ instructions are strictly needed: one of the following two
subsets would suffice:
\begin{enumerate}
\item \mnemonic{saes.v3.encs},
      \mnemonic{saes.v3.encsm},
      \mnemonic{saes.v3.decs} and
      \mnemonic{saes.v3.decsm}.
\item \mnemonic{saes.v3.encs},
      \mnemonic{saes.v3.encm},
      \mnemonic{saes.v3.decs} and
      \mnemonic{saes.v3.decm}.
\end{enumerate}

The first set is more performant in terms of instructions executed per
AES round.
However, it places the (Inv)SubBytes and (Inv)MixColumns operations
sequentially and so has a longer timing path.
The second set requires $2$x more instructions per round, but has a
shorter timing path.

\begin{figure}

\begin{subfigure}[b]{1.0\textwidth}
\begin{lstlisting}
saes.v3.encs(rs1, rs2, bs):                 // SubBytes Only
    t0.8  = rs1.8[bs]
    x.8   = AESSBox[t0]
    u.32  = {0, 0, 0, x}
    rd.32 = ROTL32(u, 8*bs) ^ rs2.32

saes.v3.encm(rs1, rs2, bs):                 // MixColumns only
    x.8   = rs1.8[bs]
    u.32  = {GFMUL(x,3) , x, x, GFMUL(x,2)}
    rd.32 = ROTL32(u, 8*bs) ^ rs2.32

saes.v3.encsm(rs1, rs2, bs):                // SubBytes & MixColumns
    t0.8  = rs1.8[bs]
    x.8   = AESSBox[t0]
    u.32  = {GFMUL(x,3) , x, x, GFMUL(x,2)}
    rd.32 = ROTL32(u, 8*bs) ^ rs2.32
\end{lstlisting}
\caption{Encrypt instruction pseudo code.}
\label{fig:pesudo:aes:v3:enc}
\end{subfigure}

\begin{subfigure}[b]{1.0\textwidth}
\begin{lstlisting}
saes.v3.decs(rs1, rs2, bs):                 // InvSubBytes Only
    t0.8  = rs1.8[bs]
    x.8   = INVAESSBox[t0]
    u.32  = {0, 0, 0, x}
    rd.32 = ROTL32(u, 8*bs) ^ rs2.32

saes.v3.decm(rs1, rs2, bs):                 // InvMixColumns Only
    x.8   = rs1.8[bs]
    u.32  = {GFMUL(x,11),GFMUL(x,13),GFMUL(9),GFMUL(14)}
    rd.32 = ROTL32(u, 8*bs) ^ rs2.32

saes.v3.decsm(rs1, rs2, bs):                // InvSubBytes & InvMixColumns
    t0.8  = rs1.8[bs]
    x.8   = INVAESSBox[t0]
    u.32  = {GFMUL(x,11),GFMUL(x,13),GFMUL(9),GFMUL(14)}
    rd.32 = ROTL32(u, 8*bs) ^ rs2.32
\end{lstlisting}
\caption{Decrypt instruction pseudo code.}
\label{fig:pesudo:aes:v3:dec}
\end{subfigure}
\caption{AES instruction variant 3.}
\end{figure}
