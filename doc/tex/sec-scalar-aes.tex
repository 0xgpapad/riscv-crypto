
\newpage
\subsection{Scalar AES Acceleration}

This section details $3.5$ proposals for acceleration of
the AES block cipher \cite{nist:fips:197} within a scalar RISC-V core,
obeying the two-read-one-write constraint on general purpose register
file accesses.
Performance and RTL benchmarks for these
instruction proposals are found in Section
\ref{sec:benchmark:aes}.

\subsubsection{RV32 Instructions}

\begin{cryptoisa}
saes32.encs      rd, rs1, rs2, bs // Encrypt: SubBytes
saes32.encsm     rd, rs1, rs2, bs // Encrypt: SubBytes & MixColumns
saes32.decs      rd, rs1, rs2, bs // Decrypt: SubBytes
saes32.decsm     rd, rs1, rs2, bs // Decrypt: SubBytes & MixColumns
\end{cryptoisa}

These instructions are a very lightweight proposal, derived from
\cite{MJS:20}.
They are designed to enable a partial T-Table based implementation
of AES in hardware, where the SubBytes, ShiftRows and MixColumns
transformations are all rolled into a single instruction, with the
per-byte results then accumulated.
The {\tt bs} immediate operand is a 2-bit {\em Byte Select}, and indicates
which byte of the input word is operated on.
Pseudo-code for each instruction is found in figure
\ref{fig:pseudo:aes:rv32}.

\begin{figure}[h]
\begin{lstlisting}[language=pseudo]
saes32.encs(rs1, rs2, bs):                 // SubBytes Only
    t0.8  = rs2.8[bs]
    x.8   = AESSBox(t0)
    u.32  = {0, 0, 0, x}
    rd.32 = ROTL32(u, 8*bs) ^ rs1.32

saes32.encsm(rs1, rs2, bs):                // SubBytes & MixColumns
    t0.8  = rs2.8[bs]
    x.8   = AESSBox(t0)
    u.32  = {GFMUL(x,3) , x, x, GFMUL(x,2)}
    rd.32 = ROTL32(u, 8*bs) ^ rs1.32

saes32.decs(rs1, rs2, bs):                 // InvSubBytes Only
    t0.8  = rs2.8[bs]
    x.8   = InvAESSBox(t0)
    u.32  = {0, 0, 0, x}
    rd.32 = ROTL32(u, 8*bs) ^ rs1.32

saes32.decsm(rs1, rs2, bs):                // InvSubBytes & InvMixColumns
    t0.8  = rs2.8[bs]
    x.8   = InvAESSBox(t0)
    u.32  = {GFMUL(x,11),GFMUL(x,13),GFMUL(9),GFMUL(14)}
    rd.32 = ROTL32(u, 8*bs) ^ rs1.32
\end{lstlisting}
\caption{Pseudocode for the lightweight AES instructions targeting the
RV32 base architecture.}
\label{fig:pseudo:aes:rv32}
\end{figure}


% ------------------------------------------------------------

\newpage
\subsubsection{RV64 Instructions}

\begin{cryptoisa}
saes64.sub      rd, rs1        // SubBytes only, for KeySchedule
saes64.encsm.lo rd, rs1, rs2   // Encrypt ShiftRows, SubBytes, MixColumns
saes64.encsm.hi rd, rs1, rs2   //
saes64.encs.lo  rd, rs1, rs2   // Encrypt ShiftRows, SubBytes
saes64.encs.hi  rd, rs1, rs2   //

saes64.imix     rd, rs1        // InvMixColumns for Decrypt KeySchedule
saes64.decsm.lo rd, rs1, rs2   // Decrypt ShiftRows, SubBytes, MixColumns
saes64.decsm.hi rd, rs1, rs2   //
saes64.decs.lo  rd, rs1, rs2   // Decrypt ShiftRows, SubBytes
saes64.decs.hi  rd, rs1, rs2   //
\end{cryptoisa}

These instructions are for RV64 only.
They implment the SubBytes, ShiftRows and MixColumns transformations of AES
over two instructions.
Each instruction takes two 64-bit registers as input, which represents
the entire 128 bit state of the AES cipher.
The instructions use the equivilent inverse cipher construction
\cite{nist:fips:197}[Page 23, Section 5.3.5].
Hence there are additional instruction specifically for performing the
inverse MixColumns transformation as part of the modified key schedule.
The byte mapping of input register values to AES state and output register
values is shown in figure \ref{fig:aes:rv64:mapping}.
Pseudo code for the instructions is found in figure
\ref{fig:pesudo:aes:rv64}.

These instructions are designed to be implemented using macro-op fusion or
operand memoisation.
This is similar to the recommended \mnemonic{mulh}, \mnemonic{mul}
sequence in the M extension to compute a full $32*32->64$ bit
multiplication result \cite{riscv:spec:user}[Section 7.1].

\begin{itemize}
\item
The {\tt *.lo} variants compute the first 8 bytes of the next round
state, while the {\tt *.hi} variants compute the last 8 bytes of the
next round state.
By performing the (Inverse) ShiftRows transformation before the
(Inverse) SubBytes transformation, no SubBytes computations need to be
thrown away.
In this way, the {\tt *.lo/*.hi} encoding bit acts as an input selector.
See the pseudo code in figure \ref{fig:pesudo:aes:rv64} to see how this works.
\item
The {\tt encsm}/{\tt decsm} instructions perform the (Inverse) SubBytes,
ShiftRows and MixColumns Transformations.
\item
The {\tt encs}/{\tt decs} instructions perform the (Inverse) SubBytes and
ShiftRows Transformations. They are used for the last round of AES only.
\item
The {\tt sub} instruction applies $4$ sboxes to the low
$4$ bytes in the source register, and writes them to the corresponding
byte in the destination register.
The high $4$ bytes are left un-modified.
It is used for the Key Schedule only.
\item
The \mnemonic{imix} instruction applies only the inverse MixColumns
transformation to two columns of the state array, packed into a single
64-bit register.
It is used to create the inverse cipher key schedule, according to
the equivilent inverse cipher construction in
\cite{nist:fips:197}[Page 23, Section 5.3.5].
\end{itemize}

This proposal requires $6$ instructions per AES round:
$2$ \mnemonic{ld} instructions to load the round key,
$2$ \mnemonic{xor} to add the round key to the current state
and
$2$ of the relevent AES encrypt/decrypt instructions to perform the
    SubBytes, ShiftRows and MixColumns round functions.
This adds up too approximately $80$ instructions per AES-128 block
encryption, including pre/post-amble instructions.

\begin{figure}
\begin{subfigure}[b]{1.0\textwidth}
\centering
\begin{bytefield}[endianness=big,bitwidth=0.014\linewidth]{64}
\bitheader{0,7,8,15,16,23,24,31,32,39,40,47,48,55,56,63} \\
\bitboxes{8}{{rs2.8[7]}{rs2.8[6]}{rs2.8[5]}{rs2.8[4]}{rs2.8[3]}{rs2.8[2]}{rs2.8[1]}{rs2.8[0]}} \bitbox{8}{{\bf rs2}} \\
\bitboxes{8}{{rs1.8[7]}{rs1.8[6]}{rs1.8[5]}{rs1.8[4]}{rs1.8[3]}{rs1.8[2]}{rs1.8[1]}{rs1.8[0]}} \bitbox{8}{{\bf rs1}}
\end{bytefield}
Input Register Values
\end{subfigure}

\begin{subfigure}[b]{1.0\textwidth}
\vspace{0.2cm}
\centering
\begin{bytefield}[endianness=big,bitwidth=0.02\linewidth]{32}
\bitheader{0,7,8,15,16,23,24,31} \\
\bitboxes{8}{{b0=rs1.8[0]}{b4=rs1.8[4]}{b8 =rs2.8[0]}{b12=rs2.8[4]}} \\
\bitboxes{8}{{b1=rs1.8[1]}{b5=rs1.8[5]}{b9 =rs2.8[1]}{b13=rs2.8[5]}} \\
\bitboxes{8}{{b2=rs1.8[2]}{b6=rs1.8[6]}{b10=rs2.8[2]}{b14=rs2.8[6]}} \\
\bitboxes{8}{{b3=rs1.8[3]}{b7=rs1.8[7]}{b11=rs2.8[3]}{b15=rs2.8[7]}} \\
\end{bytefield} \\
\vspace{-0.5cm}
AES State
\end{subfigure}

\begin{subfigure}[b]{1.0\textwidth}
\vspace{0.2cm}
\centering
\begin{bytefield}[endianness=big,bitwidth=0.014\linewidth]{64}
\bitheader{0,7,8,15,16,23,24,31,32,39,40,47,48,55,56,63} \\
\bitboxes{8}{{b15=rd.8[7]}{b14=rd.8[6]}{b13=rd.8[5]}{b12=rd.8[4]}{b11=rd.8[3]}{b10=rd.8[2]}{b9=rd.8[1]}{b8=rd.8[0]}} \bitbox{8}{{\bf rd(hi)}} \\
\bitboxes{8}{{b7 =rd.8[7]}{b6 =rd.8[6]}{b5 =rd.8[5]}{b4 =rd.8[4]}{b3 =rd.8[3]}{b2 =rd.8[2]}{b1=rd.8[1]}{b0=rd.8[0]}} \bitbox{8}{{\bf rd(lo)}}
\end{bytefield}
Output Register Values
\end{subfigure}
\caption{
Mapping of AES State bytes between input and output registers for
AES Variant 4.
}
\label{fig:aes:rv64:mapping}
\end{figure}

\begin{figure}
\begin{lstlisting}[language=pseudo]
saes.sub(rs1):               // SubBytes Only for Encrypt KeySchedule
    rd.8[i]  = AESSBox(rs1.8[i]) for i=0..3
    rd.8[j]  =         rs1.8[j]  for j=4..7

saes.enc(rs1, rs2, mix, hi): // SubBytes, ShiftRows, MixColumns
    t1.128    = AESShiftRows(rs2 || rs1)
    t2.64     = t1.64[1] if hi else t1.64[0]
    t3.8[i]   = AESSBox(t2.8[i]) for i=0..7
    rd.32[0]  = AESMixColumn(t3.32[0]) if mix else t3.32[0]
    rd.32[1]  = AESMixColumn(t3.32[1]) if mix else t3.32[1]

saes.dec(rs1, rs2, mix, hi): // InvSubBytes, InvShiftRows, InvMixColumns
    t1.128    = InvAESShiftRows(rs2 || rs1)
    t2.64     = t1.64[1] if hi else t1.64[0]
    t3.8[i]   = InvAESSBox(t2.8[i]) for i=0..7
    rd.32[0]  = InvAESMixColumn(t3.32[0]) if mix else t3.32[0]
    rd.32[1]  = InvAESMixColumn(t3.32[1]) if mix else t3.32[1]

saes.imix(rs1):              // Inverse MixColumns
    rd.32[0] = InvAESMixColumns(rs1.32[0])
    rd.32[1] = InvAESMixColumns(rs1.32[1])
\end{lstlisting}
\caption{
RV64 AES instruction pseudo code.
Note how the $128$-bit {\tt [Inv]AESShiftRows} result in {\tt t1} has
either the high or low $64$ bits selected for further processing.
}
\label{fig:pesudo:aes:rv64}
\end{figure}

