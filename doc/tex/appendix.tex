
\section{SHA3 Instruction Discussions}
\label{sec:appendix:sha3}

The SHA3 secure hash function \cite{nist:fips:202} is based on
the KECCAK-P family of permutations.
SHA3 is notably slower than SHA2 when implemented in software.
It also has a large state size (1600 bits) which is very irregularly
accessed, making it difficult to accelerate
the core {\em compute} operations as part of a scalar CPU pipeline.
We distinguish between {\em compute} operations (which modify the
round function state) and {\em address} operations (which calculate
indexes into the round function state) when motivating these instructions.

The core operations of the KECCAK-P round function are rotations
and XORs, which are already well supported by the RISC-V
base and Bitmanip architectures.
The round function state is accessed as a $5*5$ array of
64-bit words.
All indexes into the state array are generated by a function:
\lstinline{index(x,y) = (x % 5) + 5 * (y % 5)}.

When developing lightweight accelerator instructions for SHA3, we
consider two broad implementation options:
\begin{itemize}
\item Loop unrolled: Here, all of the loops of the round function are
    unrolled, meaning that all variations of the \lstinline{index}
    function are computed at compile time, and are emitted as immediate
    offsets to load and store instructions.
\item Loop rolled-up: The loops are not unrolled, and the
    \lstinline{index} functions are re-computed on every loop iteration.
\end{itemize}

