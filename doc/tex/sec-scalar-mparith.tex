
% ============================================================================

\subsection{Multi-precision Arithmetic}

\note{These instruction are marked for removal, since their benefits
      can be made up for using micro-architectural techniques.}

Multi-precision arithmetic is commonly used in public key cryptography.
RISC-V struggles with long arithmetic for two reasons:

\begin{itemize}
\item A lack of carry / overflow detection. This hinders the arithmetic
    side of implementing multi-precision arithmetic.

\item A lack of indexed load and store instructions.
    Multi-precision arithmetic typically involves stepping through
    at-least three different arrays at different indices: two operands
    and a result.
    This results in a lot of pointer arithmetic at the end of loops
    on RISC-V.
\end{itemize}

\question{
These instructions introduce the ``double width write-back" idiom to
RISC-V.
How acceptable is this?
Which other instructions could take advantage of this?
How well does this overlap with what the P (DSP) extension task group
is proposing?
}

\todo{
Benchmarking flow for these instructions based on
long-multiply / modular exponentiation.
}

\subsubsection{Multi-precision Multiply Accumulate Unsigned}

\begin{cryptoisa}
RV32, RV64:
    mmulu   rdp, rs1, rs2, rs3  // Variant 1 - double width write-back
    
    mmulu   rd,  rs1, rs2, rs3  // Variant 2
    mmuluh  rd,  rs1, rs2, rs3  //  - Hi/LO
\end{cryptoisa}

\begin{lstlisting}[]
// Equivalent RV32IM / RV64IM assembly code listing. rdp = (rd2,rd1)
mul     t1  , rs1, rs2  //       t1   = low(rs1 * rs2)
mulhu   rd2 , rs1, rs2  // (rd2, t1)  =     rs1 * rs2
add     rd1 , t1 , rs3  //      rd1   = low(rs1 * rs2) + rs3
sltu    t1  , rd1, t1   //       t1   = rd1 < t1
add     rd2 , rd2, rs2  //      rd2  += t1
\end{lstlisting}

The \mnemonic{mmulu} instruction performs an unsigned multiply
of two \XLEN sources, forming a $2*$\XLEN result.
The third \XLEN source register is then added to the $2*$\XLEN result.

For variant 1,
the $2*$\XLEN result is then written back to an odd-even register
pair \rdp.

For variant 2, the low or high \XLEN bits are written to the destination
register for the \mnemonic{mmulu} or \mnemonic{mmuluh} instructions
respectively.

\subsubsection{Multi-precision Accumulate Unsigned}

\begin{cryptoisa}
RV32, RV64:
    maccu   rdp, rs1, rs2, rs3  // Variant 1 : rdp = (rs1 || rs2) + rs3
    maccu   rdp, rs1            // Variant 2 : rdp =  rdp         + rs3
\end{cryptoisa}

\begin{lstlisting}[]
// Equivalent RV32IM / RV64IM assembly code listing. rdp = (rd2,rd1)
add     rd1, rs2, rs3
sltu    rs1, rd1, rs2
add     rd2, rs2, rs1   // (rd1,rd2) = (rs1,rs2)+rs3
\end{lstlisting}

Variant 1 of the \mnemonic{maccu} instruction
concatenates source registers
{\tt rd2}
and
{\tt rd1}
to create a $2*$\XLEN word.
To this,
{\tt rs3} is added,
and the full double-\XLEN result is written back to
an odd/even register pair {\tt rdp}.

Variant 2 does the same, but uses {\tt rdp} as an operand and is
destructive.

\note{This instruction is designed to be used in conjunction with
\mnemonic{mmulu}.}

