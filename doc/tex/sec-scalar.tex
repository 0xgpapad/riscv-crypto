
As per the RISC-V Cryptographic Extensions Task Group charter:
``{\em The committee will also make ISA extension proposals for lightweight
scalar instructions for 32 and 64 bit machines that improve the performance
and reduce the code size required for software execution of common algorithms
like AES and SHA and lightweight algorithms like PRESENT and GOST}".

\bigskip

For context, some these instructions have been developed based on academic
work at the University of Bristol as part of the XCrypto project
\cite{MPP:19},
and work by
Paris Telecom on acceleration of lightweight block ciphers
\cite{TGMGD:19}.

\question{
Implementation Diversity.
There are often many different ways of implementing certain
standardised cryptographic algorithms (AES T-Table v.s. packed for example).
Given that different implementation styles can have security implications
as well, what should the TG policy be on enabling implementation diversity?
By encouraging a particular style of implementation, more specific and
light-weight instructions can be defined to accelerate specifically that
implementation (See \cite{TG:06}).
This may come with flexibility costs, and possibly limit implementers
choices in terms of security and attack countermeasures.
}

\question{
Chicken and Egg Problems. While security must always be the first design
criteria for a new cipher, cryptographers can weight their choice of
primitives by how well they are supported by existing micro-processors.
If suddenly a new primitive becomes well supported by new
architectures, how does this impact cipher design?
Is this a motivation to include some level of generally / speculatively
useful stuff?
See \cite{block:salsa20, LSYRR:04}.
Likewise, criteria for ``lightweight" ciphers might include suitability
for hardware.
This might mean narrow data widths (e.g. SPARX \cite{DPUVGB:16})
which though excellent for hardware, are less than a CPU word-width,
making operations like addition, shifts and rotate {\em more}
awkward, not less.
}


% ============================================================================

\import{./}{sec-scalar-bitmanip.tex}
\import{./}{sec-scalar-lut4.tex}
\import{./}{sec-scalar-mparith.tex}
\import{./}{sec-scalar-aes.tex}
\import{./}{sec-scalar-sha2.tex}
\import{./}{sec-scalar-sha3.tex}

% ============================================================================

\subsection{Auto-aligning Indexed Load and Store}
\label{sec:ildst}

\begin{cryptoisa}
RV32, RV64:
    lbx     rd,  rs1, rs2 : rd = sext(mem[rs1 + (rs2     )])
    lbux    rd,  rs1, rs2 : rd = zext(mem[rs1 + (rs2     )])
    lhx     rd,  rs1, rs2 : rd = sext(mem[rs1 + (rs2 << 1)])
    lhux    rd,  rs1, rs2 : rd = zext(mem[rs1 + (rs2 << 1)])
    lwx     rd,  rs1, rs2 : rd = sext(mem[rs1 + (rs2 << 2)])
    sbx     rs1, rs2, rs3 : mem[rs1 + (rs3     )] = rs2
    shx     rs1, rs2, rs3 : mem[rs1 + (rs3 << 1)] = rs2
    swx     rs1, rs2, rs3 : mem[rs1 + (rs3 << 2)] = rs2

RV64:
    lwux    rd,  rs1, rs2 : rd = zext(mem[rs1 + (rs2 << 2)])
    ldx     rd,  rs1, rs2 : rd = sext(mem[rs1 + (rs2 << 3)])
    sdx     rs1, rs2, rs3 : mem[rs1 + (rs3 << 3)] = rs2
\end{cryptoisa}

\note{
There is a longer discussion about the inclusion of indexed load
and store in the context of RISC-V in
Appendix \ref{sec:appendix:ildst}.
}

These instructions add indexed load and store functionality to RISC-V.
The load instructions take a base register {\tt rs1} and an offset
register {\tt rs2} to form an address.
The offset is aligned to the data type of the instruction.
Zero and sign extending variants are provided.
The store instructions do the same to form the effective address, but
use {\tt rs3} as the auto-aligned offset.
This pattern of register usage keeps the functions of {\tt rs1} and
{\tt rs2} the same as the immediate offset load and store instructions.

Indexed load and store are useful for implementing many cryptographic
algorithms.
For public key cryptography involving modular exponentiation, iterating
independently over several arrays without lots of pointer arithmetic
is beneficial.
For hash functions and symmetric key block ciphers, irregular or
non-sequential access to a state array also benefits from
being able to directly calculate an address based on an offset in a
register.

% ============================================================================

\subsection{Micro-architectural Recommendations}

\todo{Macro-op fusion suggestions, side-channel considerations.}

% ============================================================================

