
\newpage
\subsection{Scalar SHA-256 / SHA-512 Acceleration}
\label{sec:scalar:sha2}

\subsubsection{SHA-256 Instructions}

\begin{cryptoisa}
ssha256.sig0 rd, rs1 : rd = ror32(rs1, 7) ^ ror32(rs1, 18) ^ srl32(rs1, 3)
ssha256.sig1 rd, rs1 : rd = ror32(rs1,17) ^ ror32(rs1, 19) ^ srl32(rs1,10)
ssha256.sum0 rd, rs1 : rd = ror32(rs1, 2) ^ ror32(rs1, 13) ^ ror32(rs1,22)
ssha256.sum1 rd, rs1 : rd = ror32(rs1, 6) ^ ror32(rs1, 11) ^ ror32(rs1,25)
\end{cryptoisa}

The {\tt ssha256.*}
instructions implement the four $\sigma$ and $\sum$ functions used in
the SHA256 hash function \cite[Section 4.1.2]{nist:fips:180:4}.
These operations are be supported for a both RV32 and RV64 targets.
For RV32, the entire XLEN source register is operated on.
For RV64, the low 32-bits of the XLEN register are read and operated on,
with the result {\em zero} extended to XLEN bits.
Though named for SHA256, the instructions work for both the
SHA-224 and SHA-256 parameterisations as described in
\cite{nist:fips:180:4}.

\subsubsection{SHA-512 Instructions}

\begin{cryptoisa}
RV32:
  ssha512.sum0r rd, rs1, rs2 : rd = sll32(rs1,25) ^ sll32(rs1,30)  ^ srl32(rs1,28) ^
                                    sll32(rs2, 7) ^ sll32(rs2, 2)  ^ sll32(rs2, 4)
  
  ssha512.sum1r rd, rs1, rs2 : rd = sll32(rs1,25) ^ sll32(rs1,30)  ^ srl32(rs1,28) ^
                                    sll32(rs2, 7) ^ sll32(rs2, 2)  ^ sll32(rs2, 4)
  
  ssha512.sig0l rd, rs1, rs2 : rd = srl32(rs1, 1) ^ srl32(rs1, 7) ^ srl32(rs1, 8) ^
                                    sll32(rs2,31) ^ sll32(rs2,25) ^ sll32(rs2,24)
  
  ssha512.sig0h rd, rs1, rs2 : rd = srl32(rs1, 1) ^ srl32(rs1, 7) ^ srl32(rs1, 8) ^
                                    sll32(rs2,31) ^               ^ sll32(rs2,24)
  
  ssha512.sig1l rd, rs1, rs2 : rd = srl32(rs1, 3) ^ srl32(rs1, 6) ^ srl32(rs1,19) ^
                                    sll32(rs2,29) ^ sll32(rs2,26) ^ sll32(rs2,13)
  
  ssha512.sig1h rd, rs1, rs2 : rd = srl32(rs1, 3) ^ srl32(rs1, 6) ^ srl32(rs1,19) ^
                                    sll32(rs2,29) ^               ^ sll32(rs2,13)

RV64:
  ssha512.sig0 rd, rs1 : rd = ror64(rs1, 1) ^ ror64(rs1,  8) ^ srl64(rs1, 7)
  ssha512.sig1 rd, rs1 : rd = ror64(rs1,19) ^ ror64(rs1, 61) ^ srl64(rs1, 6)
  ssha512.sum0 rd, rs1 : rd = ror64(rs1,28) ^ ror64(rs1, 34) ^ ror64(rs1,39)
  ssha512.sum1 rd, rs1 : rd = ror64(rs1,14) ^ ror64(rs1, 18) ^ ror64(rs1,41)
\end{cryptoisa}

The \mnemonic{ssha512.*}
instructions implement the four $\sigma$ and $\sum$ functions used in
the SHA512 hash function \cite[Section 4.1.3]{nist:fips:180:4}.

The RV32 instructions work by concatenating the two 32-bit {\tt rs1} and
{\tt rs2} registers into a 64-bit word.
The high or low 32-bits of the full 64-bit function result are then
written to the destination register depending on the instruction.

For the \mnemonic{ssha512.sum*r} instructions, the operation is based
purely on rotations;
the high or low 32-bits of the result can be selected by swapping
the input source registers to the instruction.
For the \mnemonic{sha512.sig*[l|h]} instructions, which include shifts,
the {\tt *l} instruction writes the {\em low} 32-bits of the $\sigma$
transform, and the {\tt *h} instruction writes the {\em high} 32-bits.

The RV64 instructions compute the entire $\sigma$ and $\sum$ functions
based on a single input register, and write the result to {\tt rd}.

Though named for the SHA-512 parameterisation, the instructions
can be used for all of the SHA-384, SHA-512, SHA-512/224 and SHA-512/256
parameterisations as described in \cite{nist:fips:180:4}.

\note{
The remaining two core functions in the SHA256/512
algorithms are the $Ch$ and $Maj$ functions:
\begin{itemize}
\item \lstinline{Ch(x,y,z)  = (x & y) ^ (~x & z)}
\item \lstinline{Maj(x,y,z) = (x & y) ^ ( x & z) ^ ( y & z )}
\end{itemize}
As ternary functions, they are much too expensive in terms of
opcode space to consider for inclusion as dedicated instructions for
such a specialist use-case.
}
