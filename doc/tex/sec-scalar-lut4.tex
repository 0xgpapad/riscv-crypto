
% ============================================================================

\subsection{LUT4 Instruction}

\begin{cryptoisa}
lut4lo  rd, rs1, rs2
    for i = 0..7 : rd.4[i] = rs2.4[rs1.4[i]&0x7] if (rs1.4[i] <  8) else 0

lut4hi  rd, rs1, rs2
    for i = 0..7 : rd.4[i] = rs2.4[rs1.4[i]&0x7] if (rs1.4[i] >= 8) else 0

lut4    rd, rs1, rs2
    for i = 0..15 : rd.4[i] = rs2.4[rs1.4[i]]
\end{cryptoisa}

The \mnemonic{lut4*} instructions are used to implement 4-bit lookup tables
on every nibble in a source word.
Many lightweight block ciphers use 4x4 SBoxes:
PRINCE\cite{block:prince},
PRESENT\cite{block:present},
Rectangle\cite{block:rectangle},
GIFT\cite{block:gift},
Twine\cite{block:twine},
Skinny, MANTIS\cite{block:skinny},
Midori \cite{block:midori}.

On RV32, the lookup step is split into two stages.
The \mnemonic{lut4lo} instruction
updates nibbles in the destination with the looked-up value
iff the index is less than eight.
The \mnemonic{lut4hi} version does
the same for index values greater than/equal to eight.
The results can then be or'd together.
An example implementation of an $8$-nibble parallel SBox using these
instructions is found in \figref{example:lut4:1}

On RV64, the entire set of LUT elements fits in a single source register.
The RV64 only \mnemonic{lut4} instruction stores the entire lut in
\rstwo, and uses each nibble in \rsone as an index into it.

Equivalent C code listings for the instructions are found in
\figref{equiv:c:lut4}.

%\begin{figure}
%\begin{lstlisting}[style=compact]
%lut4lo:
%lut4hi:
%\end{lstlisting}
%\caption{
%    High level description of the 
%    \mnemonic{lut4lo} and \mnemonic{lut4hi} instructions.
%    Here \xreg{rd}, \xreg{rs1} and \xreg{rs2} are 32-bit wide registers.
%    When executing on RV64, the results are \zeroextended to \XLEN bits.
%}
%\end{figure}

\begin{figure}
\begin{lstlisting}[style=ASM]
sbox_4bit:
    lut4lo  a3, a0, a1      // a0 = indexes, a1 = low  8 LUT nibbles
    lut4hi  a4, a0, a2      // a0 = indexes, a2 = high 8 LUT nibbles
    or      a0, a3, a4      // Or results together.
    ret                     // Function Return
\end{lstlisting}
\caption{
    Implement 8 parallel 4-to-4 bit SBox operations on RV32 using
    the \mnemonic{lut4hi} and \mnemonic{lut4lo} instructions.
    The Inputs to the SBox are stored in \xreg{a0}.
    The high and low $8$ elements of the
    LUT are stored in \xreg{a2} and \xreg{a1} respectively.
}
\label{fig:example:lut4:1}
\end{figure}

\begin{figure}
\begin{lstlisting}[style=C]
uint32_t lut4_lo (uint32_t rs1, uint32_t rs2) {
    uint32_t result = 0;
    for(int i = 0; i < 32; i += 4) {
        uint8_t idx =  (rs1 >> i) & 0x7;
        uint8_t lo  = ((rs1 >> i) & 0xF) < 8;
        if(lo) { result |= ((rs2 >> (4*idx) & 0xF) << i; }
    }
    return result;
}
uint32_t lut4_hi (uint32_t rs1, uint32_t rs2) {
    uint32_t result = 0;
    for(int i = 0; i < 32; i += 4) {
        uint8_t idx =  (rs1 >> i) & 0x7;
        uint8_t hi  = ((rs1 >> i) & 0xF) > 8;
        if(hi) { result |= ((rs2 >> (4*idx) & 0xF) << i; }
    }
    return result;
}
uint64_t lut4 (uint64_t rs1, uint64_t rs2) {
    uint64_t result = 0;
    for(int i = 0; i < 64; i += 4) {
        result |= ((rs2 >> (4*((rs1 >> i)&0xF)) & 0xF) << i;
    }
    return result;
}
\end{lstlisting}
\caption{
    Equivalent C code models for the
    \mnemonic{lut4lo}, \mnemonic{lut4hi} and \mnemonic{lut4}
    instructions.
}
\label{fig:equiv:c:lut4}
\end{figure}

