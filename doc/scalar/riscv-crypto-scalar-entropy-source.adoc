[[crypto_scalar_es]]
== Entropy Source

The `sentropy` CSR provides a NIST SP 800-90 cite:[TuBaKe:18] /
BSI AIS-31 cite:[KiSc11] type Entropy Source (ES) interface.
An entropy source, by itself, is not a cryptographically secure
Random Bit Generator (RBG), but -- together with other cryptographic
components -- it can be used to build standard (and nonstandard)
RBGs of many types. Expected usage is to condition (typically, hash) the
output from an entropy source and use it to seed a cryptographically
secure Deterministic Random Bit Generator (DRBG) such as the
AES `CTR_DRBG` described in NIST SP 800-90A cite:[BaKe15].

See <<crypto_scalar_appx_es>> for a description of a self-certification
procedure, design rationale, and suggestions on how the entropy source
output can be used. For further references, see cite:[SaNeMa20,SaNeMa21].

[[crypto_scalar_sentropy]]
=== The `sentropy` CSR

`sentropy` is an S-Mode CSR at address `0x9XX` _(XXX Preliminary Assignment)_.

For security reasons, it is essential that secret entropy words are not
made available multiple times. Hence polling (reading) also must to have
the side effect of clearing the entropy source. This can be accomplished
with an instruction such as `csrrw rd, sentropy, x0`.

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 16, name: 'seed'},
{bits:  8, name: 'custom'},
{bits:  6, name: 'reserved'},
{bits:  2, name: 'OPST'},
]}
....

[%autowidth.stretch,cols="^,^,<",options="header",]
|=======================================================================
|Bits |Name |Description
|`63:32` |_Set to 0_ |Upper bits are set to zero in RV64.

|`31:30` |`OPST` |Status: `BIST` (00), `WAIT` (01), `ES16` (10), `DEAD`
(11).

|`29:24` |_reserved_ |For future use by the RISC-V specification.

|`23:16` |_custom_ |Designated for custom and experimental use.

|`15: 0` |`seed` |16 bits of randomness, only when `OPST=ES16`.
|=======================================================================

The status bits `sentropy[31:30]` = `OPST` may be `ES16` (10),
indicating successful polling, or with *no* entropy and one of three
polling failure statuses `BIST` (00), `WAIT` (01), or `DEAD` (11),
discussed below.

Each returned `ES16` represents unique randomness, even if its
numerical value is the same as that of a previously polled `ES16` value.
The security requirements of output are defined in <<crypto_scalar_es_req>>.

When `OPST` is not `ES16`, `seed` must be set to 0.
An implementation may safely set reserved and custom bits to zeros.

The Status Bits at `sentropy[31:30]`=`OPST`:

* `00` - `BIST`
indicates that Built-In Self-Test "on-demand" (BIST) statistical
testing is being performed. If the system returns temporarily to `BIST`
from any other state, this signals a non-fatal (usually non-actionable)
self-test alarm.

* `01` - `WAIT`
means that a sufficient amount of entropy is not yet available. This
is not an error condition and may (in fact) be more frequent than ES16
since true entropy sources may not have very high bandwidth.

* `10` - `ES16`
indicates success; the low bits `sentropy[15:0]` will have 16 bits of
randomness, which is be guaranteed to meet certain minimum entropy
requirements regardless of implementation.

* `11` - `DEAD`
is an unrecoverable self-test error. This may indicate a hardware
fault, a security issue, or (extremely rarely) a type-1 statistical
false positive in the continuous testing procedures. In case of a fatal
failure, an immediate lockdown may also be an appropriate response in
dedicated security devices.

**Example.** `0x000000004000ABCD` is a valid `ES16`
status output on RV64, with `0xABCD` being the `seed` value.

[[crypto_scalar_es_state,reftext="Entropy Source State Transition Diagram"]]
====
image::es_state.svg[title="Entropy Source state transition diagram.", align="center",scaledwidth=50%]
Normally the operational state alternates between WAIT
(no data) and ES16, which means that 16 bits of randomness (seed)
have been polled. BIST (Built-in Self-Test) only occurs after reset
or to signal a non-fatal self-test alarm (if reached after WAIT or
ES16). DEAD is an unrecoverable error state.
====

[[crypto_scalar_es_req]]
=== Entropy Source Requirements

The output `seed` from `sentropy` is not necessarily fully conditioned
randomness due to hardware and energy limitations of smaller, low-powered
implementations. However, minimum requirements are defined.
The main requirement is that 2-to-1 cryptographic post-processing
in 256-bit input blocks will yield 128-bit "full entropy" output blocks.
Users of `sentropy` may make this conservative assumption but are not
prohibited from using more than twice the number of seed bits relative
to the desired resulting entropy.

The entropy source can meet one (or more) of three sets of requirements:

*	<<crypto_scalar_es_req_90b>>: A physical entropy source meeting
	NIST SP 800-90B cite:[TuBaKe:18] criteria with evaluated min-entropy
	level 192 per 256 output bits (min-entropy rate 0.75).

*	<<crypto_scalar_es_req_ptg2>>: A physical entropy source meeting AIS-31
	PTG.2 cite:[KiSc11] criteria, implying average Shannon entropy rate 0.997.

*	<<crypto_scalar_es_req_virt>>: A virtual entropy source is a DRBG
	seeded from a physical entropy source. It must have at least a
	256-bit (Post-Quantum Category 5) internal security level.

All classes must be able to signal initialization, test mode, and
health alarms as required by respective standards.


[[crypto_scalar_es_req_90b]]
==== NIST SP 800-90B / FIPS 140-3 Requirements

The interface requirement is satisfied if 128 bits of _full entropy_ can be
obtained from each 256-bit (16*16 -bit) successful, but possibly
non-consecutive `sentropy` ES16 output sequence using a vetted conditioning
algorithm such as a cryptographic hash
(See Section 3.1.5.1.2, cite:[TuBaKe:18]).

Rather than attempting to define all the mathematical and architectural
properties that the entropy source must satisfy, we define that it should
pass the equivalent of SP 800-90B/C evaluation and certification for
full entropy when conditioned cryptographically in ratio 2:1 with 128-bit
output blocks.

The implication is that every 256-bit sequence should have min-entropy
of at least 192 bits, as discussed in SP 800-90C cite:[BaKeRo:21];
the likelihood of successfully guessing an individual 256-bit output
sequence should not be higher than 2^-192^ even with almost
unconstrained amount of entropy source data and computational power.

Even though the requirement is defined in terms of 128-bit full entropy
blocks, we recommend 256-bit security. This can be accomplished but using
at least 512 `seed` bits  to seed a DRBG that has 256-bit security against
attacks.

[[crypto_scalar_es_req_ptg2]]
==== BSI AIS-31 PTG.2 / Common Criteria Requirements

For alternative Common Criteria certification (or self-certification),
vendors should target AIS 31 PTG.2 requirements cite:[KiSc11] (Sect. 4.3.).
In this evaluation, `seed` bits are viewed as "internal random numbers."

In addition to AIS-31 requirements, the overall min-entropy requirement
remains, as discussed in <<crypto_scalar_es_req_90b>>.


[[crypto_scalar_es_req_virt]]
==== Virtual Sources: Security Requirement

NOTE: A virtual source is not an ISA compliance requirement. It is defined
for the benefit of the RISC-V security ecosystem so that virtual systems
may have a consistent level of security.

A virtual source is not a physical entropy source but provides
additional protection against covert channels, depletion attacks, and host
identification in operating environments that can not be entirely trusted
with direct access to a hardware resource. Despite limited trust,
implementors should try to guarantee that even such environments have
sufficient entropy available for secure cryptographic operations.

A virtual source traps access to the `sentropy` CSR, emulates it, or
otherwise implements it without direct access to a physical entropy
source. The output can be cryptographically secure pseudorandomness
instead of entropy, but must have at least 256-bit security, as defined
below. A virtual source is intended especially for guest operating
systems, sandboxes, emulators, and similar use cases.

As a technical definition, a random-distinguishing attack against
the output should require computational resources comparable or greater
than those required for exhaustive key search on a secure block cipher
with a 256-bit key (e.g., AES 256). This applies to both classical
and quantum computing models, but only classical information flows.
The overall min-entropy requirement of <<crypto_scalar_es_req_90b>>
still applies, but with this computational resource limit
( Equivalent to Post-Quantum Security Category 5 cite:[NI16] ).

Any implementation of `sentropy` that limits the security
strength shall not reduce it to less than 256 bits. If the security
level is under 256 bits, then the interface must not be available.

A virtual entropy source does not need to implement WAIT or BIST states.
It should fail (DEAD) if the host DRBG or entropy source fails. 


[[crypto_scalar_es_access]]
=== Access Control via `mseccfg.SKES`

The `sentropy` CSR is not available to general user processes. The table
below summarizes the access patterns in relation to the basic RISC-V
privilege levels. S-mode access to the entropy source is controlled via
the `mseccfg.SKES` bit. This is bit 8 of `mseccfg` CSR
_(XXX Preliminary assignment 0x747)_.

.Entropy Source Access Control.

[cols="1,1,3",options="header",]
|=======================================================================
|Mode | `sentropy` ? |Description

|*M*
|Accessible
|The `sentropy` interface is available  in machine mode.

|*S*, *HS*
|`mseccfg.SKES`
| S and HS mode may access `sentropy` directly if `mseccfg.SKES=1`,
  otherwise accesses to `sentropy` will trap with an Illegal Instruction Exception.

|*U*, *VS*, *VU*
|No
|There must be no direct access to `sentropy` from U-mode.

|=======================================================================

Note that the `HS`, `VS`, and `VU` modes are present in systems with the
Hypervisor (`H`) extension implemented.

The hypervisor (or M-mode elements) can trap attempted access to
`sentropy` and feed a less privileged guest virtual entropy source words
(<<crypto_scalar_es_req_virt>>).

If `S` / `HS` modes are implemented, then `SKES=1` will allow direct
access to the entropy source from `S` and `HS` mode, while `SKES=0`
leads to an illegal instruction exception when `sentropy` is accessed.
If both `S` and `HS` mode and `mseccfg` are not implemented in a system,
then access to the entropy source is M-mode only.

Implementations may implement `mseccfg` such that `SKES` is a read-only
constant value. Software may discover if access to `sentropy` can be
enabled in `S` and `HS` mode by writing a `1` to `SKES` and reading back
the result.

`mseccfg` exists if `Zkr` is implemented, or if it is required by other
processor features. If `Zkr` is _not_ implemented, the `SKES` bit must be
hardwired to zero.


