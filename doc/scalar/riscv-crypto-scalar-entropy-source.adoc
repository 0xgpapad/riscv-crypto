[[crypto_scalar_es]]
== Entropy Source

The `sentropy` CSR provides an interface for a NIST SP 800-90B
cite:[TuBaKe:18] or BSI AIS-31 cite:[KiSc11] compliant Entropy Source (ES).
An entropy source, by itself, is not a cryptographically secure Random
Bit Generator (RBG), but can be used to build standard (and nonstandard)
RBGs of many types with the help of symmetric cryptography. Expected usage
is to condition (typically, SHA 2/3) the output from an entropy source and
use it to seed a cryptographically secure Deterministic Random Bit Generator
(DRBG) such as AES-based `CTR_DRBG` cite:[BaKe15].
The combination of ES (`sentropy` CSR) , Conditioning, and DRBG can be used
to create random bits securely cite:[BaKeRo:21].

See <<crypto_scalar_appx_es>> for a description of a certification and 
self-certification procedure, design rationale, and more detailed 
suggestions on how the entropy source output can be used. For further
references, see cite:[SaNeMa20,SaNeMa21].

[[crypto_scalar_sentropy]]
=== The `sentropy` CSR

The entropy source is accessed via S Mode CSR `sentropy` at address `0x546`.
It must be read (polled) with a destructive instruction such as 
`csrrw rd, sentropy, x0`.

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 16, name: 'seed'},
{bits:  8, name: 'custom'},
{bits:  6, name: 'reserved'},
{bits:  2, name: 'OPST'},
]}
....

[%autowidth.stretch,cols="^,^,<",options="header",]
|=======================================================================
|Bits |Name |Description
|`63:32` |_Set to 0_ |Upper bits are set to zero in RV64.

|`31:30` |`OPST` |Status: `BIST` (00), `WAIT` (01), `ES16` (10), `DEAD`
(11).

|`29:24` |_reserved_ |For future use by the RISC-V specification.

|`23:16` |_custom_ |Designated for custom and experimental use.

|`15: 0` |`seed` |16 bits of randomness, only when `OPST=ES16`.
|=======================================================================

The status bits `sentropy[31:30]` = `OPST` may be `ES16` (10),
indicating successful polling, or one of three entropy polling failure
statuses `BIST` (00), `WAIT` (01), or `DEAD` (11), discussed below.

Each returned `ES16` `seed` represents unique randomness, even if its
numerical value is the same as that of a previously polled `ES16` value.
The `seed` security requirements of output are defined in 
<<crypto_scalar_es_req>>. When `OPST` is not `ES16`, `seed` must be set to 0.
An implementation may safely set reserved and custom bits to zeros.

For security reasons, the interface guarantees that secret entropy
words are not made available multiple times. Hence polling (reading) must
also have the side effect of clearing (wipe-on-read) the `seed` contents and
changing the state to `WAIT` (unless there is another entropy `seed`
immediately available for `ES16`). Other states (`BIST`, `WAIT`, and `DEAD`)
may be unaffected by polling.

Attempted non-destructive (no write) access to `sentropy` causes an Illegal
Instruction Exception, as does any operation without appropriate privileges.
See <<crypto_scalar_es_access>>.


The Status Bits at `sentropy[31:30]`=`OPST`:

* `00` - `BIST`
indicates that Built-In Self-Test "on-demand" (BIST) testing is being
performed. If `OPST` returns temporarily to `BIST` from any other
state, this signals a non-fatal (usually non-actionable) self-test alarm.

* `01` - `WAIT`
means that a sufficient amount of entropy is not yet available. This
is not an error condition and may (in fact) be more frequent than ES16
since true entropy sources may not have very high bandwidth.

* `10` - `ES16`
indicates success; the low bits `sentropy[15:0]` will have 16 bits of
randomness, which is guaranteed to meet certain minimum entropy
requirements, regardless of implementation.

* `11` - `DEAD`
is an unrecoverable self-test error. This may indicate a hardware
fault, a security issue, or (extremely rarely) a type-1 statistical
false positive in the continuous testing procedures. In case of a fatal
failure, an immediate lockdown may also be an appropriate response in
dedicated security devices.

**Example.** `0x000000004000ABCD` is a valid `ES16`
status output on RV64, with `0xABCD` being the `seed` value.

[[crypto_scalar_es_state,reftext="Entropy Source State Transition Diagram"]]
====
image::es_state.svg[title="Entropy Source state transition diagram.", align="center",scaledwidth=50%]
Normally the operational state alternates between WAIT
(no data) and ES16, which means that 16 bits of randomness (seed)
have been polled. BIST (Built-in Self-Test) only occurs after reset
or to signal a non-fatal self-test alarm (if reached after WAIT or
ES16). DEAD is an unrecoverable error state.
====

[[crypto_scalar_es_req]]
=== Entropy Source Requirements

The output `seed` from `sentropy` is not necessarily fully conditioned
randomness due to hardware and energy limitations of smaller, low-powered
implementations. However, minimum requirements are defined.
The main requirement is that 2-to-1 cryptographic post-processing
in 256-bit input blocks will yield 128-bit "full entropy" output blocks.
Users of `sentropy` may make this conservative assumption but are not
prohibited from using more than twice the number of seed bits relative
to the desired resulting entropy.

The entropy source can meet one (or more) of three sets of requirements:

*	<<crypto_scalar_es_req_90b>>: A physical entropy source meeting
	NIST SP 800-90B cite:[TuBaKe:18] criteria with evaluated min-entropy
	level 192 per 256 output bits (min-entropy rate 0.75).

*	<<crypto_scalar_es_req_ptg2>>: A physical entropy source meeting AIS-31
	PTG.2 cite:[KiSc11] criteria, implying average Shannon entropy rate 0.997.

*	<<crypto_scalar_es_req_virt>>: A virtual entropy source is a DRBG
	seeded from a physical entropy source. It must have at least a
	256-bit (Post-Quantum Category 5) internal security level.

All classes must be able to signal initialization, test mode, and
health alarms as required by respective standards.


[[crypto_scalar_es_req_90b]]
==== NIST SP 800-90B / FIPS 140-3 Requirements

The interface requirement is satisfied if 128 bits of _full entropy_ can be
obtained from each 256-bit (16*16 -bit) successful, but possibly
non-consecutive `sentropy` ES16 output sequence using a vetted conditioning
algorithm such as a cryptographic hash
(See Section 3.1.5.1.2, cite:[TuBaKe:18]).

Rather than attempting to define all the mathematical and architectural
properties that the entropy source must satisfy, we define that it should
pass the equivalent of SP 800-90B/C evaluation and certification for
full entropy when conditioned cryptographically in ratio 2:1 with 128-bit
output blocks.

The implication is that every 256-bit sequence should have min-entropy
of at least 192 bits, as discussed in SP 800-90C cite:[BaKeRo:21];
the likelihood of successfully "guessing" an individual 256-bit output
sequence should not be higher than 2^-192^ even with (almost)
unconstrained amount of entropy source data and computational power.

Even though the requirement is defined in terms of 128-bit full entropy
blocks, we recommend 256-bit security. This can be accomplished by using
at least 512 `seed` bits to initialize a DRBG that has 256-bit security.

[[crypto_scalar_es_req_ptg2]]
==== BSI AIS-31 PTG.2 / Common Criteria Requirements

For alternative Common Criteria certification (or self-certification),
vendors should target AIS 31 PTG.2 requirements cite:[KiSc11] (Sect. 4.3.).
In this evaluation, `seed` bits are viewed as "internal random numbers."

In addition to AIS-31 requirements, the overall min-entropy requirement
remains, as discussed in <<crypto_scalar_es_req_90b>>.


[[crypto_scalar_es_req_virt]]
==== Virtual Sources: Security Requirement

NOTE: A virtual source is not an ISA compliance requirement. It is defined
for the benefit of the RISC-V security ecosystem so that virtual systems
may have a consistent level of security.

A virtual source is not a physical entropy source but provides
additional protection against covert channels, depletion attacks, and host
identification in operating environments that can not be entirely trusted
with direct access to a hardware resource. Despite limited trust,
implementors should try to guarantee that even such environments have
sufficient entropy available for secure cryptographic operations.

A virtual source traps access to the `sentropy` CSR, emulates it, or
otherwise implements it without direct access to a physical entropy
source. The output can be cryptographically secure pseudorandomness
instead of entropy, but must have at least 256-bit security, as defined
below. A virtual source is intended especially for guest operating
systems, sandboxes, emulators, and similar use cases.

As a technical definition, a random-distinguishing attack against
the output should require computational resources comparable or greater
than those required for exhaustive key search on a secure block cipher
with a 256-bit key (e.g., AES 256). This applies to both classical
and quantum computing models, but only classical information flows.
The virtual source security requirement maps to Post-Quantum Security
Category 5 cite:[NI16], so that virtual sources can be used for cryptography.

Any implementation of `sentropy` that limits the security
strength shall not reduce it to less than 256 bits. If the security
level is under 256 bits, then the interface must not be available.

A virtual entropy source does not need to implement `WAIT` or `BIST` states.
It should fail (`DEAD`) if the host DRBG or entropy source fails and
there is insufficient seeding material for the host DRBG.


[[crypto_scalar_es_access]]
=== Access Control via `mseccfg.SKES`

The `sentropy` CSR is not available to general user processes. The table
below summarizes the access patterns in relation to the basic RISC-V
privilege levels. S-mode access to the entropy source is controlled via
the `mseccfg.SKES` bit. This is bit 8 of `mseccfg` CSR.

The interface guarantees that access to this CSR will make `seed` entropy
values available only once. All successful accesses will have the
side effect of clearing (polling) the register. A nondestructive read
attempt (such as `CSRRS` / `CSRRC` with rs1=x0 or `CSRRSI` / `CSRRCI`
with zero immediate) on `sentropy` will raise an Illegal Instruction
Exception.

.Entropy Source Access Control.

[cols="1,1,3",options="header",]
|=======================================================================
|Mode | Can poll? |Description

|*M*
|Yes
|The `sentropy` interface is available in machine mode.

|*S*, *HS*
|`mseccfg.SKES`
| S and HS mode may access `sentropy` directly if `mseccfg.SKES=1`,
  otherwise accesses to `sentropy` will trap with an Illegal Instruction
  Exception.

|*U*, *VS*, *VU*
|No
|There must be no direct access to `sentropy` from U-mode.

|=======================================================================

Note that the `HS`, `VS`, and `VU` modes are present in systems with the
Hypervisor (`H`) extension implemented.

The hypervisor (or M-mode elements) can trap attempted access to
`sentropy` and feed a less privileged guest virtual entropy source words
(<<crypto_scalar_es_req_virt>>).

If `S` / `HS` modes are implemented, then `SKES=1` will allow direct
access to the entropy source from `S` and `HS` mode, while `SKES=0`
leads to an illegal instruction exception when `sentropy` is accessed.
If both `S` and `HS` mode and `mseccfg` are not implemented in a system,
then access to the entropy source is M-mode only.

Implementations may implement `mseccfg` such that `SKES` is a read-only
constant value. Software may discover if access to `sentropy` can be
enabled in `S` and `HS` mode by writing a `1` to `SKES` and reading back
the result.

`mseccfg` exists if `Zkr` is implemented, or if it is required by other
processor features. If `Zkr` is _not_ implemented, the `SKES` bit must be
hardwired to zero.


