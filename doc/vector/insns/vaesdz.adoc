[[insns-vaesdz, Vector AES decrypt round zero]]
= vaesdz.[vv, vs]

Synopsis::
Vector AES round zero decryption instruction.

Mnemonic::
vaesdz.vs vd, vs2, vs1

Encoding (Vector-Scalar)::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 'OP-V'},
{bits: 5, name: 'vd'},
{bits: 3, name: 'OPMVV'},
{bits: 5, name: 'vs1'},
{bits: 5, name: 'vs2'},
{bits: 1, name: 'vm=1'},
{bits: 6, name: 'funct6'},
]}
....

Arguments::

[%autowidth]
[%header,cols="4,2,2,2,2,2"]
|===
|Register
|Direction
|EGW
|EGS 
|EEW
|Definition

| Vs2 | input  | 128  | 4 | 32 | round state
| Vs1 | input  | 128  | 4 | 32 | round key
| Vd  | output | 128  | 4 | 32 | new round state 
|===

Description:: 
Perform the round-0 decryption function of the AES block cipher.

The inputs and outputs to this instruction are comprised of 128-bit element groups.
Each `EGW=128` element group of source `vd` holds the current round state and each `EGW=128` element group of `vs2`
holds the round key. Each `EGW=128` element group next round state output is produced by applying the AddRoundkey
step to the corresponding inputs.
This instruction must always be implemented such that its execution latency does not
depend on the data being operated upon.    

Note::
This instruction only exists in the .vs form because the .vv form would be identical to the VXOR instruction.

- AddRoundKey(state,roundkey)


This instruction operates on element groups in the source and destination registers:

- Element Group Width (EGW) = 128 bits
- Effective Element Width (EEW) = 32 bits
- Element Group Size (EGS) = 4 elements


This instruction treats `EEW=32` and `EGS=4`, regardless of `vtype.vsew`
In order to properly specify the number of elements, vl needs to be set to
vl = `vtype.vsew`/128. If vstart is not zero, it needs to be scaled similarly.
This instruction requires that `Zvl128b` be implemented (i.e `VLEN>=128`).

Operation::
[source,sail]
--
function clause execute (VAESDS(vs2, vd, vv)) = {
  assert(VLEN>=128);
// calculate the number of element groups (eg)
  eg = (vl/EGS) 
  foreach (i from vstart to eg) {
    let keyelem = if vv then i else 0;
    let state : bits(128) = get_velem(vd, EGW=128, i);
    let rkey  : bits(128) = get_velem(vs2, EGW=128, keyelem);
    let ark   : bits(128) = state ^ rkey;
    set_velem(vd, EGW=128, i, ark);
  }
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zvkns>>
| v0.1.0
| In Development
|===
