[[insns-vsm3c, SM3 Compression]]
= vsm3c.vi

Synopsis::
Vector SM3 Compression

Mnemonic::
vsm3c.vi vd, vs2, rnds

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 'OP-P'},
{bits: 5, name: 'vd'},
{bits: 3, name: 'OPMVV'},
{bits: 5, name: 'uimm'},
{bits: 5, name: 'vs2'},
{bits: 1, name: '1'},
{bits: 6, name: '101011'},
]}
....

Arguments::

[%autowidth]
[%header,cols="4,2,2,2,2,2"]
|===
|Register
|Direction
|EGW
|EGS
|EEW
|Definition

| Vd   | input  | 256  | 8 | 32 | Current state {A,B,C,D,E,F,G,H}
| uimm | input  | -    | - | -  | round number (rnds)
| Vs2  | input  | 256  | 8 | 32 | Message words {w[0], w[1], -, -, w[4], w[5], -, -}
| Vd   | output | 256  | 8 | 32 | Next state {A,B,C,D,E,F,G,H}
|===

Description::
Performs 2 rounds of SM3 Compression, producing eight 32-bit outputs in
a 256-bit 8-element group.

The round number is provided by the unsigned 5-bit `rnds` unsigned immediate. Legal values are 0 - 31
and indicate which group of two rounds are being performed. For example, if rnds=1,
then rounds 2 and 3 are being performed.

[NOTE]
====
The round number is used in the rotation of the constant as well to inform the
behavior which differs between rounds 0-15, and rounds 16-63.
====

It treats each 256-bit 8-element group of `vd` as eight 32-bit words,
and each 256-bit 8-element group of `vs2` as eight 32-bit words. Only 4 of these words are consumed by
this instruction, the rest are don't-cares.

vs2 = {w[j], w[j+1], w[j+2], w[j+3], w[j+4], w[j+5], w[j+6], w[j+7]}

The values consumed by the instruction are

vs2 = {w[j], w[j+1], -, -, w[j+4], w[j+5], -, -}

Where the "-" characters are not consumed and are therefore don't cares.

This instruction consumes the "W" message schedule inputs and internally generates the "W'" values as needed

This instruction treats `EEW=32` regardless of `vtype.vsew`
`vl` needs to be set to eight times the number of element groups.
If vstart is not zero, it needs to be scaled similarly.
This instruction requires that `Zvl128b` be implemented (i.e `VLEN>=128`).

Operation::
[source,sail]
--
function clause execute (VSM3C(rnds, vs2)) = {
  assert((vl%EGS)<>0)       // vl must be a multiple of EGS
  assert((vstart%EGS)<>0) //  vstart must be a multiple of EGS

  eg_len = (vl/EGS)
  eg_start = (vstart/EGS)
  
  foreach (i from eg_start to eg_len-1) {

  let {a, b, c, d, e, f, g, h} : bits(256) : bits(256) = get_velem(vd, 256, i);
  let {w0, w1, u_w2, u_w3, w4, w5, u_w6, u_w7} : bits(256) = get_velem(vd, 256, i);
         // u_w inputs are unused

  let x0 :bits(32) = w0 ^ w4;  // W'[0]
  let x1 :bits(32) = w1 ^ w5;  // W'[1]

  let j = 2 * rnds;
  let ss1 : bits(32) = ROL32(ROL32(A, 12) + E + ROL32(T_j(j), j % 32), 7);
  let ss2 : bits(32) = ss1 ^ ROL32(A, 12);
  let tt1 : bits(32) = FF_j(A, B, C, j) + D + ss2 + x0;
  let tt2 : bits(32) = GG_j(E, F, G, j) + H + ss1 + w0;
  D = C;
  let : bits(32) C1 = ROL32(B, 9);
  B = A;
  let A1 : bits(32) = tt1;
  H = G;
  let G1 : bits(32) = ROL32(F, 19);
  F = E;
  let E1 : bits(32) = P_0(tt2);

  j = 2 * round + 1;
  ss1 = ROL32(ROL32(A1, 12) + E1 + ROL32(T_j(j), j % 32), 7);
  ss2 = ss1 ^ ROL32(A1, 12);
  tt1 = FF(A1, B, C1, j) + D + ss2 + x1;
  tt2 = GG_j(E1, F, G1, j) + H + ss1 + w1;
  D = C1;
  let C2 : bits(32) = ROL32(B, 9);
  B = A1;
  let A2 : bits(32) = tt1;
  H = G1;
  let G2 = : bits(32) ROL32(F, 19);
  F = E1;
  let E2 = : bits(32) P_0(tt2);

  // Update the destination register.
  set_velem(vd, 256, i, (A2, A1, C2, C1, E2, E1, G2, G1));
      }

  RETIRE_SUCCESS
  }

  function FF1(X, Y, Z) = ((X) ^ (Y) ^ (Z))
  function FF2(X, Y, Z) = (((X) & (Y)) | ((X) & (Z)) | ((Y) & (Z)))

  function FF_j(X, Y, Z, J) = (((J) <= 15) ? FF1(X, Y, Z) : FF2(X, Y, Z))

  function GG1(X, Y, Z) = ((X) ^ (Y) ^ (Z))
  function GG2(X, Y, Z) = (((X) & (Y)) | ((~(X)) & (Z)))
.
  function GG_j(X, Y, Z, J) = (((J) <= 15) ? GG1(X, Y, Z) : GG2(X, Y, Z))

  function T_j(J) = (((J) <= 15) ? (0x79CC4519) : (0x7A879D8A))

  function P_0(X) = ((X) ^ ROL32((X),  9) ^ ROL32((X), 17))



--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zvksh>>
| v0.1.0
| In Development
|===
