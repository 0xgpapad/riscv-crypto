[[insns-vaeskf, Vector AES Forward KeySchedule]]
= vaeskf.vi

Synopsis::
Vector AES Forward KeySchedule

Mnemonic::
vaeskf.vi vd, vs2, uimm

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 'OP-V'},
{bits: 5, name: 'vd'},
{bits: 3, name: 'OPIVI'},
{bits: 5, name: 'uimm'},
{bits: 5, name: 'vs2'},
{bits: 1, name: 'vm'},
{bits: 6, name: 'funct6'},
]}
....

Arguments::

[%autowidth]
[%header,cols="4,2,2,2,2,2"]
|===
|Register
|Direction
|EGW
|EGS 
|EEW
|Definition

| Vd   | input  | 128  | 4 | 32 | PreviousRoundKey (only read if rcon[4]==1)
| uimm | input  | -    | - | -  | RoundConstant (rcon)
| Vs2  | input  | 128  | 4 | 32 | CurrentRoundKey
| Vd   | output | 128  | 4 | 32 | NextRoundKey
|===

Description:: 
This instruction implements a single round of the forward AES KeySchedule. It operates on `EGW=128` element groups. It treats each element group of `vs2` as the CurrentRoundKey,
and each element group of `vd` as RoundKeyA.
It writes the 128-bit result to the corresponding element group in `vd`.

The most significant bit of the immediate (i.e., rcon[4]) is used to indicate if the instruction is
performing an AES-256 instruction (rcon[4]==1) or an AES-128 instruction (rcon[4]==0). For AES-128, the 
vd source operand is not used.

NOTE::
Since the vd source operand is not used when rcon[4]==0, implementations can choose to not read vd.
There is no functional harm in implementations reading vd, it just creates an artificial RAW hazard.



The instruction encoding is reserved if vector register group `vd` overlaps with `vs2`.

NOTE::
The same instruction is used for generating AES-128 and AES-256 round keys, but the
code sequence is different. Vd is only a source if rcon[4]==1 as two previous round
keys are needed for AES-256, but only one previous round key is needed for AES-128.
// For AES-128, the NextRoundKey is generated from a single
// 128-bit Round Key, while for AES-256, the NextRoundKey is generated from two
// 128-bit Round Keys. 
Also, each AES-128 round Key is generated by a process that
includes operating on a specific constant for that round. The _even_ AES-256
Round Keys are generated by a similar process. The _odd_ AES-256 Round Keys
are generated using a simpler process that doesn't operate on a constant. We
denote these odd rounds by using the value 0 for the RoundConstant.

The RoundConstant for each round is shown in the table below. 

For AES-128, RoundKey[0] is the 128-bit Cipher Key. Each subsequent Round Key is generated
word by word. The most significant word of the NextRoundKey is produced by performing
a function on the least significant word 
by using the least significant word of the current round key, performing a function on it,
and exclusive ORing it with the most sign
    NextRoundKey[3] = (SubWord(RotWord(CurrentRoundKey[0])) XOR Const[rcon]) XOR CurrentRoundKey[3];
    NextRoundKey[2] = NextRoundKey[3] XOR CurrentRoundKey[2];
    NextRoundKey[1] = NextRoundKey[2] XOR CurrentRoundKey[1];
    NextRoundKey[0] = NextRoundKey[1] XOR CurrentRoundKey[0];

When producing AES-256 Round Keys, the process is different for even and odd rounds. For even rounds,
the process is similar to AES-128:

  NextRoundKey[3] = SubWord(RotWord(CurrentRoundKey[0])) XOR Const[rcon] XOR PreviousRoundKey[3];
  NextRoundKey[2] = NextRoundKey[3] XOR PreviousRoundKey[2];
  NextRoundKey[1] = NextRoundKey[2] XOR PreviousRoundKey[1];
  NextRoundKey[0] = NextRoundKey[1] XOR PreviousRoundKey[0];

For odd rounds, procvess is simpler and no Round Constant is used:

  NextRoundKey[3] = SubWord(CurrentRoundKey[0]) XOR PreviousRoundKey[3];
  NextRoundKey[2] = NextRoundKey[3] XOR PreviousRoundKey[2];
  NextRoundKey[1] = NextRoundKey[2] XOR PreviousRoundKey[1];
  NextRoundKey[0] = NextRoundKey[1] XOR PreviousRoundKey[0];

The RoundConstant is stored in the unsigned 5-bit `rnd` immediate. Legal
values for rnd[3:0] are 0 - 10. Out of range values are reserved.


[%autowidth]
[%header,cols="4,4,2,2,2,2"]
|===
|rcon[4:0] AES-128
|rcon[4:0] AES-256 
|AES-128 round
|AES-256 round
|Value
|Comment

| 0x00000 | 0x10000 |- | odd | none       | Used for odd AES-256 rounds
| 0x00001 | 0x10001 |1 |  2   | 0x01000000 |
| 0x00010 | 0x10010 |2 |  4   | 0x02000000 |
| 0x00011 | 0x10011 |3 |  6   | 0x04000000 | 
| 0x00100 | 0x10100 |4 |  8   | 0x08000000 |
| 0x00101 | 0x10101 |5 |  10  | 0x10000000 |
| 0x00110 | 0x10110 |6 |  12  | 0x20000000 |
| 0x00111 | 0x10111 |7 |  14  | 0x40000000 | Highest constant for AES-256
| 0x01000 | -       |8 |  -   | 0x80000000 |
| 0x01001 | -       |9 |  -   | 0x1b000000 |
| 0x01010 | -       |10|  -   | 0x36000000 | Highest constant for AES-128
|===  

[NOTE]
====
The constants for AES-128 Rounds 9 and 10 may appear to follow a different pattern from
the other constants. However, they all follow the same pattern where the most significant
byte is multiplied by 2 modulo x^8^ + x^4^ + X^3^ + x + 1.
====


This instruction ignores `vtype.vsew`. +
The number of element groups to be processed is `vl`/`EGS`.
`vl` must be set to the number of `EEW=32` elements to be processed and 
therefore must be a multiple of `EGS=4`. + 
Likewise, `vstart` must be a multiple of `EGS=4`.


[NOTE]
====
The AES KeySchedule consumes 5 32-bit words to compute the next 4 32-bit
words of the KeySchedule, while the round function consumes these words
in chunks of 128-bits.

The difference between AES-128 and AES-256 is where the 5th word comes from.
In AES-128 it comes from the current round key, and in AES-256 it comes from the
previous round key. When using this instruction for AES-128, the register holding
the current round key should also be used for the previous round key argument.
====


Operation::
[source,Sail]
--
function clause execute (VAESESKF(rcon, vd, vs2)) = {
 if((unsigned(rcon[3:0]) > 10) then {
    handle_illegal();  RETIRE_SUCCESS
  } else {
  assert((vl%EGS)<>0)       // vl must be a multiple of EGS
  assert((vstart%EGS)<>0) //  vstart must be a multiple of EGS

  eg_len = (vl/EGS)
  eg_start = (vstart/EGS)

// Insert constant table here

  foreach (i from eg_start to eg_len-1) {
      let CurrentRoundKey[3:0]  : bits(32)  = get_velem(vs2, EGW=128, i);
      if rcon[4] == 1 then
        let RoundKeyB[3:0] : bits(32)  = get_velem(vd, EGW=128, i); // Previous round key
      else
         let RoundKeyB[3:0] : bits(32)  = CurrentRoundKey;

      let w[3] : bits(32) = if (rcon==0) then
        RoundKeyB[3] XOR SubWord(CurrentRoundKey[0])
      else
        RoundKeyB[3] XOR SubWord(RotWord(CurrentRoundKey[0])) XOR Const[rcon];
      w[2] : bits(32) = w[3] XOR RoundKeyB[2]
      w[1] : bits(32) = w[2] XOR RoundKeyB[1]
      w[0] : bits(32) = w[1] XOR RoundKeyB[0]
      set_velem(vd, EGW=128, i, w[3:0]);
    }
    RETIRE_SUCCESS
  }
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zvkns>>
| v0.1.0
| In Development
|===
