[[insns-vaeskf, Vector AES Forward KeySchedule]]
= vaeskf.vi

Synopsis::
Vector AES Forward KeySchedule

Mnemonic::
vaeskf.vi vd, vs2, uimm

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 'OP-V'},
{bits: 5, name: 'vd'},
{bits: 3, name: 'OPIVI'},
{bits: 5, name: 'uimm'},
{bits: 5, name: 'vs2'},
{bits: 1, name: 'vm'},
{bits: 6, name: 'funct6'},
]}
....

Arguments::

[%autowidth]
[%header,cols="4,2,2,2,2,2"]
|===
|Register
|Direction
|EGW
|EGS 
|EEW
|Definition

| Vd   | input  | 128  | 4 | 32 | Round key 2 (AES256 ? Previous Round Key : Current Round Key)
| uimm | input  | -    | - | -  | Round constant (rcon)
| Vs2  | input  | 128  | 4 | 32 | Current Round key
| Vd   | output | 128  | 4 | 32 | Next round key
|===

Description:: 
This instruction implements a single round of the forward AES KeySchedule.
It treats each `EGW=128` element group of `vs2` as the current AES round key,
and each `EGW=128` element group of `vd` as the previous AES round key.
The round number is stored in the unsigned 5-bit `rnd` immediate. Legal values are 1 - 14.
Out of range values signal an illegal instruction exception.

It applies a single AES KeySchedule round to each element group, and
writes the 128-bit result to the corresponding element group in `vd`.

This instruction only returns the generated key to the same element group as the source.
If it is desired to have the same key in all vector groups, either the input vector groups
need to contain the same values, or the output from a particular group needs to be "broadcast"
to the other groups using an instruction such as vrgather.

[%autowidth]
[%header,cols="4,2,2,2,2"]
|===
|rcon[3:0]
|AES-128 round
|AES-256 round
|Value
|Comment

| 0x0000 | - | odd | none       | Used for odd AES-256 rounds
| 0x0001 |  1 |  2   | 0x01000000 |
| 0x0010 |  2 |  4   | 0x02000000 |
| 0x0011 |  3 |  6   | 0x04000000 | 
| 0x0100 |  4 |  8   | 0x08000000 |
| 0x0101 |  5 |  10  | 0x10000000 |
| 0x0110 |  6 |  12  | 0x20000000 |
| 0x0111 |  7 |  14  | 0x40000000 | Highest constant for AES-256
| 0x1000 |  8 |  -   | 0x80000000 |
| 0x1001 |  9 |  -   | 0x1b000000 | 0x01 x 29 over GF(28)
| 0x1010 | 10 |  -   | 0x36000000 | Highest constant for AES-128
|===  

This instruction ignores `vtype.vsew`. +
The number of element groups to be processed is `vl`/`EGS`.
`vl` must be set to the number of `EEW=32` elements to be processed and 
therefore must be a multiple of `EGS=4`. + 
Likewise, `vstart` must be a multiple of `EGS=4`

[NOTE]
====
The AES KeySchedule consumes 5 32-bit words to compute the next 4 32-bit
words of the KeySchedule, while the round function consumes these words
in chunks of 128-bits.
The difference between AES-128 and AES-256 is where the 5th word comes from.
In AES-128 it comes from the current round key, and in AES-256 it comes from the
previous round key. When using this instruction for AES-128, the register holding
the current round key should also be used for the previous round key argument.
====


Operation::
[source,Sail]
--
function clause execute (VAESESKF(rcon, vd, vs2)) = {
 if((unsigned(rcon) > 10) then {
    handle_illegal();  RETIRE_SUCCESS
  } else {
  assert((vl%EGS)<>0)       // vl must be a multiple of EGS
  assert((vstart%EGS)<>0) //  vstart must be a multiple of EGS

  eg_len = (vl/EGS)
  eg_start = (vstart/EGS)

// Insert constant table here

  foreach (i from eg_start to eg_len-1) {
      let current[3:0]  : bits(32)  = get_velem(vs2, EGW=128, i);
      let previous[3:0] : bits(32)  = get_velem(vd, EGW=128, i);

      let w[3] : bits(32) = if (rcon==0) then
        previous[3] XOR SubWord(current[0])
      else
        previous[3] XOR SubWord(RotWord(current[0])) XOR Const[rcon];
      w[2] : bits(32) = w[3] XOR previous[2]
      w[1] : bits(32) = w[2] XOR previous[1]
      w[0] : bits(32) = w[3] XOR previous[0]
      set_velem(vd, EGW=128, i, w[3:0]);
    }
    RETIRE_SUCCESS
  }
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zvkns>>
| v0.1.0
| In Development
|===