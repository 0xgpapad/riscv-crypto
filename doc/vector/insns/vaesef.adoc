[[insns-vaesef, Vector AES encrypt final round]]
= vaesef.v

Synopsis::
Vector AES final round encryption instruction.

Mnemonic::
vaesef.v vd, vs2

Encoding (Vector)::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 'OPMVV'},
{bits: 5, name: 'vd'},
{bits: 3, name: 'func3'},
{bits: 5, name: 'vs1=0'},
{bits: 5, name: 'vs2'},
{bits: 1, name: 'vm'},
{bits: 6, name: 'funct6'},
]}
....


Description:: 
This instruction implements the final-round encryption function of the AES block cipher. The inputs and outputs to this instruction are comprised of 128-bit element groups.  Each element group of source `vd` holds the current round state and each 128-bit element group of `vs1` holds the round key. Each element group next round state output is produced by applying the SubBytes, ShiftRows, and AddRoundkey steps to the corresponding inputs. This instruction must always be implemented such that its execution latency does not depend on the data being operated upon.    

- SubBytes(state)
- ShiftRows(state)
- AddRoundKey(state,roundkey)


This instruction operates on element groups in the source and destination registers:

- Element Group Width (EGW) = 128 bits
- Effective Element Width (EEW) = 32 bits
- Element Group Size (EGS) = 4 elements

Operation::
[source,pseudocode]
--
function clause execute (VAESEF(vs1, vd) = {
  assert(VLEN>=128); 
  // calculate the number of element groups (eg)
  eg = (vl/EGS)  
  foreach (i from vstart to eg) {
    let state : bits(128) = get_velem(vd, EGW=128, i);
    let rkey  : bits(128) = get_velem(vs1, EGW=128, i);
    let sb    : bits(128) = aes_fwd_sub_bytes(state);
    let sr    : bits(128) = aes_fwd_shift_rows(sb);
    let ark   : bits(128) = sr ^ rkey;
    set_velem(vd, EGW=128, i, ark);
  }
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zvkns>>
| v0.1.0
| In Development
|===