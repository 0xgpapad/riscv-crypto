[[insns-vclmulgf, Vector Carryless Multiply over Galois-Field 2^128]]
= vclmulgf.vv

Synopsis::
Vector Carryless Multiply over Galois-Field 2^128

Mnemonic::
vclmulgf.vv vd, vs2, vs1

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 'OP-V'},
{bits: 5, name: 'vd'},
{bits: 3, name: 'OPMVV'},
{bits: 5, name: 'vs1'},
{bits: 5, name: 'vs2'},
{bits: 1, name: 'vm=1'},
{bits: 6, name: 'funct6'},
]}
....

Arguments::

[%autowidth]
[%header,cols="4,2,2,2,2,2"]
|===
|Register
|Direction
|EGW
|EGS 
|EEW
|Definition

| Vs1 | input  | 128  | 4 | 32 | multiplier
| Vs2 | input  | 128  | 4 | 32 | multiplicand
| Vd  | output | 128  | 4 | 32 | carry-less product GF[2^128^]
|===

Note::
There are two options for how we define this instruction. The first option is the simpler where
the inputs are the multiplier and the multiplicand and the output is the product modulo the irreducible
polynomial. This would require that prior to this instruction the AES output would have been bytewise
bit-reversed and then added (XORed) with the output of the previous vclmulgf instruction.
The second option would have a third input, which would be the output of the previous vclmulgf. It would
have the AES output as an input, on which it would perform the bytewise bit-reversal and the XORing
with the previous output. This second instruction would encompass 3 instructions, but would also incur
additional delay. 

Description:: 
This instruction performs a multiply between two 128-bit polynomials modulo the irreducible polynomial
x^128^ + x^7^ + x^2^ + x + 1

It treats each EGW=128 element group of `vs1` and `vs2` as the input polynomials.
This instruction is intended to be used to implement a GHASH~H~ as defined in NIST Special Publication 800-38D
"Recommendation for Block Cipher Modes of Operation:
Galois/Counter Mode (GCM) and GMAC". See
link:https://csrc.nist.gov/publications/detail/sp/800-38d/final[here]
This specification orders the coefficients in increasing order from left to right x~0~x~1~...x~127~
for a polynomial x~0~ + x~1~u +x~2~ u^2^ + ... + x~127~u^127^.

In order to match the GHASH specification, the bits within bytes are reversed internally to the instruction
so that the least significant bit is on the left. Thus, instead of the bits being ordered (7,6,5,4,3,2,1,0) they would be ordered (0,1,2,3,4,5,6,7).

In order to avoid having to swap the order of the bytes, we are relying on the property:

  rev(A) * rev(B) = rev(A*B)>>1

// This instruction effectively applies a single 128x128 carryless multiply producing a 255-bit product which it reduces
// by multiplying the most significant 127 bits by the irreducible polynomial x^128^ + x^7^ + x^2^ + x + 1,
// and adding it to the least significant 128 bits,
// producing a 128-bit result which is written to the corresponding element group in `vd`.

This instruction ignores `vtype.vsew`. +
The number of element groups to be processed is `vl`/`EGS`.
`vl` must be set to the number of `EEW=32` elements to be processed and 
therefore must be a multiple of `EGS=4`. + 
Likewise, `vstart` must be a multiple of `EGS=4`

// It requires that `Zvl128b`be implemented (i.e `VLEN>=128`).

Operation::
[source,pseudocode]
--
function clause execute (VCLMULGF(vs2, vs1, vd)) = {
  // operands are input with bits reversed in each byte

  assert((vl%EGS)<>0)       // vl must be a multiple of EGS
  assert((vstart%EGS)<>0) //  vstart must be a multiple of EGS
  elementgroups = (vl/EGS)
  egstart = (vstart/EGS)

  foreach (i from egstart to elementgroups) {
    let prod[255:0]   = clmul_128(get_velem(vs1,i), get_velem(vs2,i));
      // Reduce product by irreducible polynomial
    let prod[191:64] ^= clmul_64((prod[255:192], 0x87);
    let prod[127:0]  ^= clmul_64((prod[191:128], 0x87);
    set_velem(vd, EGW=128, i, prod[127:0]);
  }
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zvkg>>
| v0.1.0
| In Development
|===