**INITIAL DRAFT**  For discussion.
__This document does not reflect TG consensus yet.__

May 25, 2020  Markku-Juhani O. Saarinen <mjos@pqshield.com>


== GetEntropy - Baseline Requirements

GetEntropy provides access to a hardware-based (random) entropy source.
It is not a general-purpose random number generator by itself, but a valid
implementation should satisfy properties that allow it to be used to
*seed* secure cryptographic DRBGs (Deterministic Random Bit Generators) of
virtually any state size.

NOTE: The purpose of this baseline requirement is to guarantee that a simple,
device-independent driver component (e.g. in Linux kernel, embedded firmware,
or a cryptographic library) can use the instruction to generate truly random
bytes. If a TRNG component cannot be interfaced or conditioned in a way that
meets these criteria, it can be interfaced via regular IO interfaces and
custom drivers instead.

=== Accessing the Entropy Source

----
# Get a byte of entropy. imm=0 for baseline operation

getentropy rd, imm
----

Currently `imm` for `getentropy` has no specified input flags; the
minimum behavior described in this document applies when imm=0.
If an implementation encounters an input `imm` that it cannot interpret,
it must return FAIL and may also trap.

After the instruction, the register `rd` will contain:

.getentropy output register after call
[cols="1,1,3"]
[%autowidth]
|===
|     Bits  | Name  | Description

| XLEN-1:31 | FAIL  | Zero if seed is a valid output
|       ... |       | Undefined
|       7:0 | seed  | Output byte (randomness)
|===

In other words, a caller may interpret the return value as C type `int` on
all architectures, with negative values indicating failure (FAIL) and
the low 8 bits of positive values having a random seed byte.

NOTE:   The FAIL and non-fail conditions may convey additional information
in extended (non-baseline) implementations; for example additional entropy
bits may be available, and indicators of the internal state of the generator
may be conveyed. However we urge implementors against creating unnecessary
information "status oracles" or to allow the instruction to disable or
affect the TNRG output in any significant way. All such information flows
and interaction mechanisms can be potentially used in attacks.

====    Baseline requirements

*   **IID**: The output should be __Independent and Identically Distributed__
    (IID), meaning that the output distribution does not change over time
    and that output bytes do not convey information about each other.
    This implies that IID tests in <<SP800-90B>> are consistently passed
    and that the construction of the physical source and sampling mechanism
    implies nothing against the IID assumption.

*   **Entropy:** A minimum requirement is that 128 bits of "full
    entropy" can be consistently obtained from each 256-bit `getentropy`
    output sequence via (vetted) cryptographic conditioning (see Section
    3.1.5.1.2 in <<SP800-90B>>). If no other information is available,
    driver developers may make this conservative assumption. Note that
    min-entropy assessment in <<SP800-90B>> requires some overhead.
    In practice we recommend the distribution to be significantly
    closer to uniform to satisfy additional usability and <<AIG31>>
    requirements.

*   **Validity:** The instruction returns FAIL if sufficient entropy is not
    available. In particular `getentropy` sets FAIL if called too rapidly in
    succession or immediately after startup. However more detailed warm-up
    tests may be delegated to the software or firmware component, as required
    for certification (the output of the software driver is to be certified,
    not the instruction).

NOTE:    These are the minimum requirements; an implementation is can
also output fully conditioned, perfectly distributed numbers. However the
instruction should be used to not pass on DRBG output unless the entropy
content and secret state of that generator are considered to be sufficient
for high-security applications (more than 256 bits).


====    Polling Randomness

The instruction returns immediately, either with a byte of randomness
satisfying the criteria above, or FAIL (high bit set).

We recommend against busy-loop polling on this instruction as it may have
relatively low bandwidth. Even though no specific interrupt sequence is
specified, it is required that the WFI instruction is available and does
not trap on systems that implement GetEntropy (WFI can be implemented as a
NOP).

As a minimum requirement for portable drivers, a FAIL from GetEntropy should
be followed by a WFI before another GetEntropy instruction is issued.
This (at least potentially) allows energy-saving sleep on MCUs and context
switching on a higher-end CPUs.

The instruction should return FAIL during its "warm-up" period. An internal
delay counter or randomness quality monitor can be implemented for this.
However secondary quality monitors can be implemented in the driver component
to comply with certification requirements.

On systems that do not have a suitable hardware generator available,
the instruction should not be available either; they should have negative
discovery and can trap instead of permanently returning FAIL. On
virtualized platforms the bytes are expected to be directly sourced from a
suitable host system resource such as the  `/dev/random` character device
or `getrandom(2)` syscalls. Note that the host random number generator
must also satisfy the 256-bit security requirement.


=== Overall RNG Architecture

Raw output from this instruction should not be used for cryptographic
purposes directly. Its purpose is to provide entropy for cryptographic
conditioning components and a DRBG (PRNG) implemented in software.

The TRNG module (scope of certification and evaluation) consists of the
hardware circuit together with a suitable driver that implements
the required health checks, cryptographic conditioning, etc.

----
         [ "NOISE" ]            //    Physical source w. stochastic model.
              |
              |     (Raw random signal.)
              V
H      [ Digitization ]         //    Sampler, photon detector, etc.
a             |
r             |     (Raw random sequence.)
d             |
w             +---> "GetNoise"  //    Optional vendor diagnostic interface.
a             |
r    [ (Mixing) Buffer ]        //    e.g. LFSR + poll/reset clock.
e             |
              V
ISA:   [ GetEntropy ]           //    Instruction, returning a byte or FAIL.
              |
S             V
o    [ Software Driver ]        //    Also part of the entropy source (ES)!
f    [ - Health checks ]        //    e.g. Startup test, continuous test.
t    [ - Cryptographic ]        //    e.g. SHA2, AES based conditioning
w    [    conditioning ]        //    input entropy 2 * h_in >= n_out output
a             |
r             V
e   [ Crypto-based DRBG ]       //    e.g. CTR_DRBG, Hash_DRBG, HMAC_DRBG
              |
              V
      [ API Interface ]         //    e.g. /dev/urandom or RAND_bytes(3)
              |
              V
 Application / Crypto Algorithm
----

==== Typical Driver functionality

NOTE:   Our discussion of software components is informational only;
we emphasize that users of `getentropy` should not expect that it produces
full-entropy output.

Some of the functions delegated to software driver component
(in system kernel, shared runtime, or cryptographic library):

-   Discovery of the instruction and its features.
-   Possible warm-up tests if required for certification such as <<FIPS140>>.
-   Cryptographic conditioning, e.g. SHA2/HMAC, AES/CMAC, AES/CBC-MAC as
    discussed in <<SP800-90B>>. This is required to compress 2*n bits of
    `getentropy` output into n bits of "full entropy".
-   Producing DRBG output using cryptographic mechanisms such as CTR_DRBG,
    Hash_DRBG, HMAC_DRBG as discussed in <<SP800-90A>>.
-   Known-answer tests of cryptographic components used for conditioning
    or DRBG, if required. These implementations can leverage the relevant
    (AES and SHA-2) cryptographic instructions.
-   Additional Health monitoring (power-up tests, software/firmware tests,
    continuous tests, critical functions tests, conditional tests, etc) as
    required by <<FIPS140>>.
-   Key zeroization and other validation interfaces. Since cryptographic keys
    are not held by the TRNG and the hardware component maintains a minimum
    correlated state, software zeroization should be sufficient.


===    Background: Criteria for Randomness

NOTE:   While we do not require entropy source implementations to be
certified designs, we do expect that they behave in a compatible manner and
do not create additional security risks to users. Self-evaluation and
testing in accordance with appropriate security standards is usually needed
to achieve this.

U.S. NIST has published a recommendation for entropy source evaluation
in 2018 <<SP800-90B>>, which complements earlier DRBG specification
<<SP800-90A>>. NIST has also made a statistical test suite
<<SP800-22>> available.

It is the intention that `getentropy` may be instantiated to meet the
Entropy Source requirements (with or without conditioning) of <<SP800-22>>.
The entropy requirements in the U.S. document focus on min-entropy and allow
cryptographic conditioning of relatively low-quality random numbers as input.

IID is an optional requirement in <<SP800-90B>>, but is needed to prevent
information leakage between processes using the `getentropy` instruction.
Furthermore, it significantly simplifies certification and vendor-independent
driver development.

A conditioning component may be applied to the output from a raw random
noise source to reduce bias and/or increase entropy rate to meet the
criteria for seed output. In this case some security evaluation approaches
will need to bypass the conditioning component and access the raw noise
sequence directly (GetNoise function of <<SP800-90B>>). This is
a vendor-specific matter (not ISA), and only needed for certification,
post-fabrication checks, and other evaluation/diagnostics; regular
applications or drivers should not need it. Such a "debug" interface must
have restricted access for security.

German BSI (Bundesamt für Sicherheit in der Informationstechnik) has also
published two methods, "AIS-31" and "AIS-20", for evaluating random number
generators. Their status is discussed in <<BSI-RAND>>. This methodology is
widely used in Common Criteria (CC) evaluations as well.

The methods discussed in "AIS-31" <<AIS31>> are related to physical
random number generators (i.e. `getentropy`), while "AIS-20" <<AIS20>>
describes deterministic random number generators. Also see <<ScKi02>>.
<<AIS31>> specifies two classes of TRNGs, P1 and P2, while <<AIS20>>
describes four classes K1, K2, K3, and K4 of DRBGs (where K4 is the highest).
There is a relationship between the two; Class P1 randomness source is
suitable of DRBGs in classes K1 and K2, while P2 source is used for K3 and
K4 DRBGs and higher overall security levels.

The requirements for the P2 source necessitate near-uniform output even from
the "raw" entropy source. For example criteria P2.i)(vii.e) requires entropy
estimate of at least 7.976 bits per byte using "test T8" in <<AIS31>>,
which is derived from Coron's test <<Co99>>. Hence we suggest that each
output byte has much more than the minimum entropy content of >4 bits per byte.

A common approach seems to be that 2*n bits from an entropy source is used
to generate n bits of "full randomness" with a cryptographic conditioner.
However <<SP800-90B>> is relatively new and fewer certifications have been
made to this standard than to Common Criteria and <<AIS31>>, so we recommend
targeting higher entropy rates.

This interface can be used by both classical Entropy Sources (ES) and
Quantum Entropy Sources (QES, see ITU <<X.1709>> for definitions), if the
QES meets the required classical entropy criteria. The use of quantum-origin
entropy (the distinguishing factor of QES) is usually only required in
protocols that have security proofs derived directly from quantum mechanics
(e.g. Quantum Key Agreement). Pure cryptographic protocols that do not
impose requirements on the physical layer communication channels usually
only require "classical" entropy; this also applies to post-quantum
cryptographic standards <<NISTPQC>>.

=== References

[[SP800-90A]][SP800-90A]
E. Barker and J. Kelsey,
"Recommendation for Random Number Generation Using Deterministic Random
Bit Generators." NIST SP 800-90A Rev 1, June 2015.
https://doi.org/10.6028/NIST.SP.800-90Ar1

[[SP800-90B]][SP800-90B]
M. S. Turan, E. Barker, J. Kelsey, K. A. McKay, M. L. Baish, and M. Boyle,
"Recommendation for the Entropy Sources Used for Random Bit Generation."
NIST SP 800-90B, January 2018.
https://doi.org/10.6028/NIST.SP.800-90B

[[SP800-22]][SP800-22]
L. Bassham, A. Rukhin, J. Soto, J. Nechvatal, M. Smid, E. Barker,
S. Leigh, M. Levenson, M. Vangel, D. Banks, N. Heckert, and J. Dray,
"A Statistical Test Suite for Random and Pseudorandom Number Generators
for Cryptographic Applications."
NIST SP 800-22 Rev. 1a, April 2010.
https://doi.org/10.6028/NIST.SP.800-22r1a

[[FIPS140]][FIPS140]
NIST,
"Security Requirements for Cryptographic Modules."
FIPS PUB 140-2, May 2001.
__(Testing on FIPS 140-2 will end in September 2020.)__
https://doi.org/10.6028/NIST.FIPS.140-2

[[FIPS140-3]][FIPS140-3]
NIST,
"Security Requirements for Cryptographic Modules."
FIPS PUB 140-3, March 2019.
__(Testing on FIPS 140-3 will commence in September 2020.)__
https://doi.org/10.6028/NIST.FIPS.140-3

[[BSI-RAND]][BSI-RAND]
BSI, "Evaluation of random number generators."
Version 0.10, BSI, March 2013.
https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Zertifizierung/Interpretationen/AIS_20_AIS_31_Evaluation_of_random_number_generators_e.html

[[AIS31]][AIS31]
W. Killman and W. Schindler.
"A proposal for: Functionality classes and evaluation methodology for true
(physical) random number generators."
AIS 31, Version 3.1, BSI, September 2001.
https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Zertifizierung/Interpretationen/AIS_31_Functionality_classes_evaluation_methodology_for_true_RNG_e.html

[[AIS20]][AIS20]
W. Schindler,
"Functionality classes and evaluation methodology for deterministic random
number generators."
AIS 20, Version 2.0, BSI, December 1999.
https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Zertifizierung/Interpretationen/AIS_20_Functionality_Classes_Evaluation_Methodology_DRNG_e.html

[[X.1709]][X.1709]
ITU,
"Quantum noise random number generator architecture."
Recommendation ITU-T X.1702, November 2019.
https://www.itu.int/rec/T-REC-X.1702-201911-I/en

[[NISTPQC]][NISTPQC]
NIST,
"Post-Quantum Cryptography Standardization."
NIST Post Quantum Cryptography project, 2017-.
https://csrc.nist.gov/Projects/post-quantum-cryptography/Post-Quantum-Cryptography-Standardization

==== Informational References

[[ScKi02]][ScKi02]
W. Schindler and W. Killmann,
"Evaluation Criteria for True (Physical) Random Number Generators Used in
Cryptographic Applications."
CHES 2002, LNCS 2523, Springer, pp. 431-449, 2002.
https://doi.org/10.1007/3-540-36400-5_31


[[HaKoMa12]][HaKoMa12]
M. Hamburg, P. Kocher, and M. E. Marson,
"Analysis of Intel's Ivy Bridge Digital Random Number Generator."
Technical Report, Cryptography Research (Prepared for Intel), March 2012.

[[Me18]][Me18]
J. P. Mechalas,
"Intel Digital Random Number Generator (DRNG): Software Implementation Guide."
Revision 2.1. Intel Technical Report, October 2018.
https://software.intel.com/content/www/us/en/develop/articles/intel-digital-random-number-generator-drng-software-implementation-guide.html

[[AMD16]][AMD17]
AMD,
"AMD Random Number Generator."
Technical Report, Advanced Micro Devices, June 2017.
https://www.amd.com/system/files/TechDocs/amd-random-number-generator.pdf

[[LiBaBo13]][LiBaBo13]
J. S. Liberty, A. Barrera, D. W. Boerstler, T. B. Chadwick,
S. R. Cottier, H. P. Hofstee, J. A. Rosser, and  M. L. Tsai,
"True hardware random number generation implemented in the 32-nm SOI
POWER7+ processor."
IBM J. of Res. and Dev., vol. 57, no. 6, pp. 4:1-4:7, Nov.-Dec. 2013.
https://doi.org/10.1147/JRD.2013.2279599

[[ShTe15]][ShTe15]
T. Shrimpton and R. S. Terashima,
"A Provable-Security Analysis of Intel’s Secure Key RNG."
EUROCRYPT 2015, LNVS 9056, Springer, pp. 77-100, 2015.
https://doi.org/10.1007/978-3-662-46800-5_4

[[BaLuMi11]][BaLuMi11]
M. Baudet, D. Lubicz, J. Micolod, and André Tassiaux,
"On the Security of Oscillator-Based Random Number Generators."
J. Cryptology, vol. 24, pp. 398-425, Springer, 2011.
https://doi.org/10.1007/s00145-010-9089-3

[[MaMo09]][MaMo09]
A. T. Markettos and S. W. Moore, "The Frequency Injection Attack on
Ring-Oscillator-Based True Random Number Generators."
CHES 2009, LNCS 5747, Springer, pp. 317-331, 2009.
https://doi.org/10.1007/978-3-642-04138-9_23

[[RaSt98]][RaSt98]
M. Raab and A. Steger,
"“Balls into Bins” — A Simple and Tight Analysis."
RANDOM 1998, LNCS 1518, Springer, pp. 159-170, 1999.
https://doi.org/10.1007/3-540-49543-6_13

[[Co99]][Co99]
J. S. Coron,
"On the Security of Random Sources."
PKC 1999, LNCS 1560, Springer, pp. 29-42, 1999.
https://doi.org/10.1007/3-540-49162-7_3

