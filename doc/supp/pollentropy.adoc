== PollEntropy - Baseline requirements for IID Entropy Sources.

**DRAFT**  For discussion.
__This document does not reflect full TG consensus yet.__

[cols="1,1,3"]
[%autowidth]
|===
| Date  | Version   | Notes

| 2020-05-25 |    - | Started. Markku-Juhani O. Saarinen <mjos@pqshield.com>
| 2020-06-16 |    - | Updated and expanded per comments from Chair and TG.
| 2020-06-20 |    - | Updated with additional health check guidance.
| 2020-06-26 |  0.0 | Gaining support! Split FAIL into BIST,WAIT,DEAD. Renamed GetEntropy as PollEntropy.
| 2020-06-27 |  0.1 | Comments and corrections from Chair (Richard Newell).
| 2020-??-?? |  0.2 | Current working version.
|===

PollEntropy provides access to a hardware-based (random) Entropy Source (ES).
It is not a general-purpose or high-bandwidth random number generator by
itself, but a valid implementation should satisfy properties that allow it
to be used to *seed* secure cryptographic DRBGs (Deterministic Random Bit
Generators) of virtually any state size and security level.

The main design goal is that standards-compliant random number generators can
be built using PollEntropy and other RISC-V cryptographic instructions
(notably AES and SHA). Common true random bit generator specification
frameworks intended as targets for this specification include
FIPS 140-3 <<FIPS140-3>> / NIST SP 800-90B <<SP800-90B>> and
BSI AIS-20 / AIS-31 <<AIS20_31>>, which is often used in conjunction with
Common Criteria certifications.  See Section 7.18
__"Entropy Estimation and Compliance with SP 800-90B"__ of
<<FIPS140-2-IG>> for some certification laboratory guidance related
to current entropy source validation processes.

The purpose of this baseline requirement is to guarantee that a simple,
device-independent driver component (e.g. in Linux kernel, embedded firmware,
or a cryptographic library) can use the instruction to generate truly random
bits. If a TRNG component cannot be interfaced or conditioned in a way that
meets these criteria, it can be interfaced via regular IO interfaces and
custom drivers instead - but that is out of scope for this specification.

=== Accessing the Entropy Source

In **Machine Mode** (if different from user-level execution):
----
# Get entropy bits. Proposing 5-bit immediate: imm=0 for baseline operation

pollentropy rd, imm
----

For purposes of this specification, this corresponds to C calling convention:
----
int PollEntropy(0);
----

After the instruction, the register `rd` (usually `A0`) will contain:

.pollentropy output in rd, after instruction:
[cols="1,1,3"]
[%autowidth]
|===
|     Bits  | Name | Description

| XLEN-1:32 |      | For RV64 sign-extend bit 31 (for arithmetic shift etc).
|     31:30 | OPST | Operational status. One of BIST (00), ES16 (01), WAIT (10), DEAD (11).
|     29:24 |      | Reserved for future use by the RISC-V specification.
|     23:16 |      | Reserved for custom and experimental use.
|      15:0 | seed | 16-bit output word (randomness) when OPST=ES16.
|===

The instruction is **non-blocking** and returns immediately, either with
sixteen bits of randomness in `rd[15:0]` and OPST set to `ES16`, or with
**no** entropy and one of three operational statuses, BIST, WAIT, or DEAD.

Nonzero values for `imm` are reserved for future use. The behavior described
in this document applies when imm=0. If an implementation encounters an input
`imm` that it cannot interpret, it must return WAIT or DEAD and may also trap.
For example `imm != 0` may be used to poll non-IID randomness (see below) and
therefore the same minimum driver requirements are not met.

In order to verify that the caller has a valid 16-bit entropy `seed` in
`rd[15:0]`, the caller must check that `rd[31:30] == 01` (ES16 state).
All other conditions should be rejected and the contents of the reserved
bits ignored. In normal operation the entropy source alternates between
ES16 and WAIT states only.

.The four states of the entropy source
[cols="1,1,1,3"]
[%autowidth]
|===
| 31| 30| Name | Description

| 0 | 0 | BIST | Built-In Self-Test in progress following a reset.
| 0 | 1 | ES16 | 16 bits of randomness available in `seed` = rd[15:0].
| 1 | 0 | WAIT | Entropy not yet available (suggest WFI before the next poll).
| 1 | 1 | DEAD | Unrecoverable error. The caller should stop polling.
|===

Additional bits may convey additional information in extended
(non-baseline, `imm != 0`) implementations; for example indications about
failure conditions or the availability of further entropy bits.
Implementors should not make any random bits available in `seed` unless
the state is ES16.

----
         reset
           |
           V
     +---[BIST]---+     BIST should be designed to be fast.
     |            |
     |  +------+  |     Normal operation alternates between WAIT and ES16:
     V  |      V  V
    [WAIT]    [ES16] == have 16 seed bits  (ignore if WAIT)
     |  ^      |  |
     |  +------+  |
     |            |
     +-->[DEAD]<--+     DEAD can actually follow from BIST or reset too!
           |
           v
       stay dead        If you read DEAD twice you're not doing it right.
----


*   **BIST** indicates a Built-In Self-Test and additional "on-demand"
    statistical testing is being performed. In typical implementations,
    BIST will last only a few milliseconds, up to a few hundred.
    Any runtime unavailability caused by continuous testing after the
    initial BIST shall be indicated with WAIT instead.

*   **WAIT** means that a sufficient amount of entropy is not yet available.
    This is not an error condition and may (in fact) be more frequent than
    ES16, since true entropy sources may not have very high bandwidth.
    If polling in a loop, we suggest calling WFI (wait for interrupt) before
    the next poll.

*   **ES16** indicates success; the low bits `rd[15:0]` will have 16 bits
    of randomness which must be guaranteed to have at least 8 bits true entropy
    regardless of implementation. For example, `0x4000ABCD` is a valid ES16
    output, with `0xABCD` being the `seed` value.

*   **DEAD** is an unrecoverable self-test error. This may indicate a
    hardware fault, a security issue, or (extremely rarely) a type-1
    statistical false positive in the continuous testing procedures.
    Implementations do not need to implement DEAD as it may not require
    an end-user notification; an immediate lock-down may be a more
    appropriate response in dedicated security devices.

NOTE:   To guarantee that no sensitive data is read twice and
that different callers don't get correlated output, hardware
implementations shall execute *wipe-on-read* on the randomness pathway
during each successful read. For the same reasons, only complete and fully
processed randomness words shall be made available via PollEntropy
(no half-conditioned buffers even in WAIT state).

WARNING:    We urge implementors against creating unnecessary information
flows ("status oracles") via the reserved bits or to allow the instruction
to disable or affect the TNRG output in any significant way. All information
flows and interaction mechanisms must be considered from an adversarial
viewpoint and implemented only if they are truly necessary and their security
impact can be fully understood. This also applies to the raw
noise source. Section 3.2.2, <<SP800-90B>> specifically states that
"The noise source state shall be protected from adversarial knowledge
or influence to the __greatest extent possible__."

WARNING:    Output `seed` from PollEntropy is not necessarily fully
conditioned randomness due to hardware limitations of smaller, low-powered
implementations. Cryptographic conditioners such as AES would be too
complex and expensive to implement solely to serve PollEntropy -- and simple,
non-cryptographic conditioners too wasteful on input entropy if higher
rates of output entropy are required. Hence a caller should not use the
output directly but poll twice the amount of required entropy, condition
it cryptographically (e.g. by hashing twice the amount needed), and use
that to seed a cryptographic DRBG. Implementors are urged to use the RISC-V
(AES and SHA) cryptographic instruction extensions to build conditioners
and DRBGs.


====    Baseline output requirements for PollEntropy(0)

*   **Entropy:** Each 16-bit output sample (`seed`) has at least 8 bits of
    independent, unpredictable true randomness (entropy). This minimum
    requirement is satisfied if - in an <<SP800-90B>> assessment - 128 bits of
    output entropy can be obtained from each 256-bit (16x16) PollEntropy
    output sequence via (a vetted) cryptographic conditioning algorithm
    (see Section 3.1.5.1.2 in <<SP800-90B>>) such as a cryptographic hash
    (SHA-2 <<FIPS180>> or SHA-3 <<FIPS202>>). Driver developers may make
    this conservative assumption but are not prohibited from using more
    than twice the number of seed bits relative to the desired resulting
    entropy.

*   **IID**: The output should be __Independent and Identically Distributed__
    (IID), meaning that the output distribution does not change over time
    and that output words do not convey information about each other.
    This implies that IID tests in <<SP800-90B>> are consistently passed
    and that the construction of the physical source and sampling mechanism
    suggests nothing against the IID assumption.

*   **Validity:** The instruction never returns ES16 if sufficient entropy
    is not available and should not set any `seed` bits either. In particular
    PollEntropy sets WAIT if called too rapidly in succession and BIST
    immediately after startup. More detailed warm-up and continuous tests
    may be delegated to the software or firmware component, as required
    for certification. (Note that the hardware/software system up to and
    including the output of the software driver is to be certified,
    not just the hardware instruction).

NOTE: The min-entropy assessment methodology in <<SP800-90B>> has a safety
margin in its confidence intervals and therefore requires each 16-bit word
to have somewhat more than 8 bits of real entropy to meet our criteria.
In practice we recommend the distribution to be significantly
closer to uniform to satisfy additional usability and <<AIS20_31>>
requirements.

NOTE: These are minimum requirements; an implementation can also output
fully conditioned, perfectly distributed numbers. However, it is required
that if a full DRBG is used as a source, it must have an internal state
with at least 256 bits of secret entropy (e.g. a CTR_DRBG built from AES-128
is never sufficient). In general, any implementation of PollEntropy that
limits the security strength shall not reduce it to less than 256 bits.
The generator should be able to support "LEVEL 5" post-quantum
cryptography standards <<NISTPQC>>.

NOTE: If cryptographic conditioning is not used, the random source
(and the circuit that implements it) may have a uniquely identifiable
hardware "signature". This may be useful in some applications (as random
sources may exhibit PUF-like features) and undesirable in others
(anonymized virtualized environments and enclaves).

====    Polling Randomness (Guidance)

In C, for an output word obtained via `x = PollEntropy(0)` the validity
check may be implemented as  `(x >> 30) == 1` and output seed derived via
`seed = x & 0xFFFF`. It is important that the validity check of two
bits is performed with a single comparison and that the reserved bits
are masked away and have no effect on program flow. This protects against
unwanted timing oracles if these bits are used to convey additional
information in the future.

An acceptable random number generator (DRBG) initialization sequence would
obtain 512 bits (32 successful calls) of PollEntropy output and hash it with
a suitable mechanism such as SHA2/3-384/512 or SHAKE256 <<FIPS180>> <<FIPS202>>
to produce the initial seed for a DRBG -- such as CTR_DRBG built from
AES-256 <<SP800-90A>>.

We recommend against busy-loop polling on this instruction as it may have
relatively low bandwidth. Even though no specific interrupt sequence is
specified, it is required that the WFI instruction is available and does
not trap on systems that implement PollEntropy (WFI can be implemented as
a NOP).

As a minimum requirement for portable drivers, a WAIT or BIST from
PollEntropy should be followed by a WFI before another PollEntropy
instruction is issued. This (at least potentially) allows energy-saving
sleep on MCUs and context switching on a higher-end CPUs.

The instruction should return BIST during its "warm-up" and start-up
testing period. An internal delay or randomness quality monitor is often
implemented for this. Secondary quality monitors can be implemented in
the driver component to comply with certification requirements.
Permanent test failures should result in unrecoverable DEAD status --
however this (DEAD reporting) can be skipped to halt the entire system
outright if that is deemed appropriate.

On systems that do not have a suitable hardware generator available,
the instruction should not be available either; they should have negative
discovery (permanently returning DEAD should not be used for this purpose
as that may initiate an immediate shutdown as it can be interpreted as
an integrity breach of the security subsystem).

On virtualized platforms, the output is expected to be directly sourced
from a suitable host system resource such as the  `/dev/random` character
device or `getrandom(2)` syscalls. Note that the host random number generator
must also satisfy the 256-bit security (secret entropy) requirement.


====    Health Tests (Guidance)

The purpose of a cryptographic entropy source is to produce secret keying
material, as well as for other purposes such as initialization vectors and
nonces. Therefore a good-quality hardware entropy source implements
appropriate controls to guarantee unpredictability, prevent leakage, and
deny adversarial control over the entropy output or its generation mechanism.
These are not intended for hardware diagnostics but for detecting security
issues. Additional "debug" mechanisms may be used if necessary, but then the
device must be outside production use.

*   **Health tests are security controls.** Health checks can take the form
    of integrity checks, start-up tests, continuous tests, and on-demand
    tests. The tests can be implemented in hardware or firmware; typically
    both. Several are mandated by security standards such as <<FIPS140>>.
    The exact choice of appropriate health tests depends on the certification
    target, system architecture, the threat model, entropy source type, and
    other factors.

*   **Avoid Unnecessary Information Flows.**  The role of the RISC-V ISA
    implementation is to try to ensure that the hardware-software interface
    minimizes avenues for adversarial information flow (called "attack
    oracles" in cryptography"); all status information that is unnecessary
    in normal operation should be eliminated. Out-of-band information such
    as (health) "status bits" or even the __timing__ of on-demand health
    checks should be considered to be potentially exploitable attack oracles.

*   **On-demand testing** is usually invoked via resetting, rebooting, or
    powering-up the hardware. Typically, the implementation will just return
    BIST during the initial start-up self-test period; in any case, the driver
    must wait for them to finish before starting cryptographic operations.
    The term "on-demand" does not mean that the end-user or application
    program should be able to manually invoke them in the field (the term is
    a throw-back to an earlier era when random number generators were not
    integrated autonomous systems and sometimes even had human operators).

*   **Continuous tests** often maintain a state (such as counters) related to
    noise or entropy output. This is potentially statistically correlated to
    some secret some keying material. A hardware-based continuous testing
    mechanism must not make such state or statistical information externally
    available, and it must be zeroized periodically or upon demand via
    reset, power-up, or similar signal. Upon continuous testing failure, the
    entropy source may first go into a "cool off" WAIT state for a short
    period, and then enter a fatal DEAD error state. Software drivers may
    handle statistical tests as they see fit.

*   **Fault attacks.** Some hardware random generators are, by their physical
    construction, more exposed to non-adversarial environmental and
    manufacturing issues than purely deterministic logic components. However,
    even such "natural" failure modes may indicate a  __fault attack__ and
    therefore should not be addressed as a diagnostic issue but as a general
    system integrity failure (see e.g. <<MaMo09>> <<KaScVe13>>).

*   **Error states are fatal**. Since the security of most cryptographic
    operations depends on the entropy source, a system-wide "default deny"
    security policy approach is appropriate for most entropy source failures.
    A hardware test failure should result in at least in DEAD, an instruction
    trap but possibly also hard reset/halt. It's a show stopper: The entropy
    source must not be allowed to run if its secure operation can't be
    guaranteed.

*   **False-positives.** The statistical nature of some tests makes
    "type-1" false positives a possibility. Security architects will
    understand to use permanent or hard-to-recover "security-fuse" lockdowns
    only if the P-value threshold of a test is such that the probability of
    false-positive is negligible over the entire device lifetime.


=== Overall RNG Architecture (Informational)


Raw output from this instruction shall not be used for cryptographic
purposes directly. Its purpose is to provide entropy for cryptographic
conditioning components and a DRBG (PRNG) implemented in software.

The construction and certification of the hardware component are left
to the vendor. This ISA document specifies requirements to its output
and assumptions that can be made when using baseline-compliant IID sources.

Some higher-level TRNG module (in the scope of a certification and
evaluation) may consist of the hardware circuit together with a suitable
driver that implements the required health checks, cryptographic
conditioning, etc. The delineation of the ISA component is as follows:

----
         [ "NOISE" ]            //    Physical source w. stochastic model.
              |
              |     (Raw "analog" signal.)
              V
H        [ Sampler ]            //    Digitizer, photon detector, etc.
a             |
r             |     (Raw random bit sequence.)
d             |
w             +-----> [ Health Checks ]  // and "GetNoise" diagnostics.
a             |
r      [ Conditioning ]         //    Usually non-cryptographic
e             |
              |     (seed)      //    Concentrated randomness: H(seed) > 8
              V
ISA:   [ PollEntropy ]          //    Returning 16 bits (ES16) or WAIT/..
              |
S             V
o    [ Software Driver ]        //    Also part of the entropy source (ES)!
f    [ - Monitoring    ]        //    e.g. More statistical things
t    [ - Cryptographic ]        //    e.g. SHA2, AES based "random pool":
w    [    conditioning ]        //    input entropy 2 * h_in >= n_out output
a             |
r             V
e      [ Secure DRBG ]          //    e.g. CTR_DRBG, Hash_DRBG, HMAC_DRBG
              |
              V
      [ API Interface ]         //    e.g. /dev/urandom or RAND_bytes(3)
              |
              V
 Application / Crypto Algorithm
----

Functionally PollEntropy implements the GetEntropy() abstract component of
SP 800-90B (with ES16 mapping to TRUE status and other statuses being FALSE).
SP 800-90B GetNoise(), if needed, can be implemented via a hardware debug
interface or vendor-specific CSR (out of scope of this specification) and
HealthTest() roughly maps to BIST and DEAD operational statuses.

==== Typical Driver functionality

NOTE:   Our discussion of software components is informational only but
we emphasize that users of PollEntropy must always implement a DRBG driver
for cryptographic use.

Some of the TRNG functions delegated to software driver component may include
(in system kernel, shared runtime, or cryptographic library):

-   Discovery of the instruction and its features.
-   Additional warm-up tests if required for certification such as <<FIPS140>>.
-   Cryptographic conditioning, e.g. SHA2/HMAC, AES/CMAC, AES/CBC-MAC as
    discussed in <<SP800-90B>>. This is required to compress 2*n (or more)
    bits of PollEntropy output into n bits of "full entropy".
-   Producing DRBG output using cryptographic mechanisms such as CTR_DRBG,
    Hash_DRBG, HMAC_DRBG as discussed in <<SP800-90A>>.
-   Known-answer tests of cryptographic components used for conditioning
    or DRBG, if required. These implementations can leverage the relevant
    (AES and SHA-2) cryptographic instructions.
-   Additional Health monitoring (power-up tests, software/firmware tests,
    continuous tests, critical functions tests, conditional tests, etc) as
    required by <<FIPS140>>.
-   Zeroization: Since plaintext cryptographic keys or other Critical
    Security Parameters (CSPs) are not held by the Entropy Source and
    the hardware component outputs non-correlated IID randomness,
    zeroization mostly affects software-controlled variables. The hardware
    system may independently implement zeroization during reset, physical
    security violation, or shutdown (but this is outside the scope of
    this ISA document).

==== Discussion

NOTE:   While we do not require entropy source implementations to be
certified designs, we do expect that they behave in a compatible manner and
do not create unnecessary security risks to users. Self-evaluation and
testing following appropriate security standards is usually needed to
achieve this.

U.S. NIST has published a recommendation for entropy source evaluation
in 2018 <<SP800-90B>>, which complements earlier DRBG specification
<<SP800-90A>>. NIST has also made a statistical test suite
<<SP800-22>> available.

German BSI (Bundesamt für Sicherheit in der Informationstechnik) has also
published two methods, AIS-20 and AIS-31, for evaluating random number
generators. Their status is discussed in <<BSI-RAND>>. This methodology is
widely used in Common Criteria (CC) evaluations.

It is the intention that PollEntropy may be instantiated to meet the
Entropy Source requirements (with or without conditioning) of <<SP800-90B>>.
The entropy requirements in the U.S. document focus on min-entropy and allow
cryptographic conditioning of relatively low-quality random numbers as input.

IID is an optional requirement in <<SP800-90B>> but is needed to
prevent information leakage between different instances that possibly
use the PollEntropy instruction and source. Furthermore, it significantly
simplifies certification and vendor-independent driver development.
However this document can be expanded to non-IID sources later.

A conditioning component may be applied to the output from a raw
random noise source to reduce bias and remove redundancy to meet
the criteria for seed output. Some security evaluation approaches
will need to bypass the conditioning component and access the raw noise
sequence directly (GetNoise function of <<SP800-90B>>). This is
a vendor-specific matter (not ISA), and only needed for certification,
post-fabrication checks, and other evaluation/diagnostics; regular
applications or drivers should not need it. Such a "debug" interface must
have restricted access for security. Any raw noise bits exported by the
abstract GetNoise function (however implemented) shall not be used in the
generation of any bits returned by the PollEntropy instruction.

The methods discussed in AIS-31 <<AIS31>> are related to physical
random number generators (i.e. PollEntropy), while AIS-20 <<AIS20>>
describes deterministic random number generators. Later the documents
were combined into <<AIS20_31>> but the older ones were not completely
superceded <<BSI-RAND>>. Anyway there are two classes of physical RNGs,
P1 and P2, while there are four classes K1-K4 of DRBGs.
There is a relationship between the two; Class P1 randomness source is
suitable for DRBGs in classes K1 and K2, while P2 source is used for K3
and K4 DRBGs.

The requirements for the P2 source necessitate near-uniform output even from
the "raw" entropy source. For example criteria P2.i)(vii.e) requires an entropy
estimate of at least 7.976 bits per byte using "test T8" in <<AIS31>>,
which is derived from Coron's test <<Co99>>. Hence we suggest that each
16-bit output word has much more than the minimum entropy content of >8 bits
(i.e. >4 bits per byte) as required by this specification.

A common approach seems to be that 2*n bits from an entropy source is used
to generate n bits of "full randomness" with a cryptographic conditioner.
However <<SP800-90B>> is relatively new and fewer certifications have been
made to this standard than to Common Criteria and <<AIS31>>, so we recommend
targeting lower redundancy.

This interface can be used by both classical Entropy Sources (ES) and
Quantum Entropy Sources (QES, see ITU <<X.1709>> for definitions) if the
QES meets the required classical entropy criteria. The use of quantum-origin
entropy (the distinguishing factor of QES) is usually only required in
protocols that have security proofs derived directly from quantum mechanics
(e.g. Quantum Key Agreement). Pure cryptographic protocols that do not
impose requirements on the physical layer communication channels usually
only require "classical" entropy. This also applies to post-quantum
cryptographic standards <<NISTPQC>>, which generally do not require a QES.


=== References

[[SP800-90A]][SP800-90A]
E. Barker and J. Kelsey,
"Recommendation for Random Number Generation Using Deterministic Random
Bit Generators." NIST SP 800-90A Rev 1, June 2015.
https://doi.org/10.6028/NIST.SP.800-90Ar1

[[SP800-90B]][SP800-90B]
M. S. Turan, E. Barker, J. Kelsey, K. A. McKay, M. L. Baish, and M. Boyle,
"Recommendation for the Entropy Sources Used for Random Bit Generation."
NIST SP 800-90B, January 2018.
https://doi.org/10.6028/NIST.SP.800-90B

[[SP800-90B-CODE]][SP800-90B-CODE]
"The SP800-90B_EntropyAssessment C++ package implements the min-entropy
assessment methods included in Special Publication 800-90B."
https://github.com/usnistgov/SP800-90B_EntropyAssessment

[[SP800-22]][SP800-22]
L. Bassham, A. Rukhin, J. Soto, J. Nechvatal, M. Smid, E. Barker,
S. Leigh, M. Levenson, M. Vangel, D. Banks, N. Heckert, and J. Dray,
"A Statistical Test Suite for Random and Pseudorandom Number Generators
for Cryptographic Applications."
NIST SP 800-22 Rev. 1a, April 2010.
https://doi.org/10.6028/NIST.SP.800-22r1a

[[FIPS140]][FIPS140]
NIST,
"Security Requirements for Cryptographic Modules."
FIPS PUB 140-2, May 2001.
__(Testing on FIPS 140-2 will end in September 2020.)__
https://doi.org/10.6028/NIST.FIPS.140-2

[[FIPS140-2-IG]][FIPS140-2-IG]
NIST and CCCS,
"Implementation Guidance for FIPS 140-2 and the Cryptographic Module
Validation Program."
CMVP Update, December 2019.
https://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Module-Validation-Program/documents/fips140-2/FIPS1402IG.pdf

[[FIPS140-3]][FIPS140-3]
NIST,
"Security Requirements for Cryptographic Modules."
FIPS PUB 140-3, March 2019.
__(Testing on FIPS 140-3 will commence in September 2020.)__
https://doi.org/10.6028/NIST.FIPS.140-3

[[FIPS180]][FIPS180]
NIST,
"Secure Hash Standard (SHS)."
FIPS PUB 180-4, August 2015.
https://doi.org/10.6028/NIST.FIPS.180-4

[[FIPS197]][FIPS197]
NIST,
"Advanced Encryption Standard (AES)."
FIPS PUB 197, November 2001.
https://doi.org/10.6028/NIST.FIPS.197

[[FIPS202]][FIPS202]
NIST,
"SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions."
FIPS PUB 202, August 2015.
https://doi.org/10.6028/NIST.FIPS.202

[[BSI-RAND]][BSI-RAND]
BSI, "Evaluation of random number generators."
Version 0.10, BSI, March 2013.
https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Zertifizierung/Interpretationen/AIS_20_AIS_31_Evaluation_of_random_number_generators_e.html

[[AIS31]][AIS31]
W. Killman and W. Schindler.
"A proposal for: Functionality classes and evaluation methodology for true
(physical) random number generators."
AIS 31, Version 3.1, BSI, September 2001.
https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Zertifizierung/Interpretationen/AIS_31_Functionality_classes_evaluation_methodology_for_true_RNG_e.html

[[AIS20]][AIS20]
W. Schindler,
"Functionality classes and evaluation methodology for deterministic random
number generators."
AIS 20, Version 2.0, BSI, December 1999.
https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Zertifizierung/Interpretationen/AIS_20_Functionality_Classes_Evaluation_Methodology_DRNG_e.html

[[AIS20_31]][AIS20_31]
W. Killmann and W. Schindler,
"A Proposal for: Functionality classes for random number generators."
AIS 20 / AIS 31, Version 2.0, BSI, December 2011.
https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Zertifizierung/Interpretationen/AIS_31_Functionality_classes_for_random_number_generators_e.html

[[X.1709]][X.1709]
ITU,
"Quantum noise random number generator architecture."
Recommendation ITU-T X.1702, November 2019.
https://www.itu.int/rec/T-REC-X.1702-201911-I/en

[[NISTPQC]][NISTPQC]
NIST,
"Post-Quantum Cryptography Standardization."
NIST Post Quantum Cryptography project, 2017-.
https://csrc.nist.gov/Projects/post-quantum-cryptography/Post-Quantum-Cryptography-Standardization



==== Informational References (Alphabetical)

[[AMD17]][AMD17]
AMD,
"AMD Random Number Generator."
Technical Report, Advanced Micro Devices, June 2017.
https://www.amd.com/system/files/TechDocs/amd-random-number-generator.pdf

[[ARM17]][ARM17]
ARM,
"ARM TrustZone True Random Number Generator: Technical Reference Manual"
ARM 100976_0000_00_en (rev. r0p0), May 2017.
http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.100976_0000_00_en

[[ARM20]][ARM20]
ARM,
"Arm Architecture Registers: Armv8, for Armv8-A architecture profile."
ARM DDI 0595 (ID033020), April 2020.
https://static.docs.arm.com/ddi0595/g/SysReg_xml_v86A-2020-03.pdf

[[BaLuMi11]][BaLuMi11]
M. Baudet, D. Lubicz, J. Micolod, and André Tassiaux,
"On the Security of Oscillator-Based Random Number Generators."
J. Cryptology, vol. 24, pp. 398-425, Springer, 2011.
https://doi.org/10.1007/s00145-010-9089-3

[[BeRePa14]][BeRePa14]
G. T. Becker, F. Regazzoni, C. Paar, and W. P. Burleson,
"Stealthy Dopant-Level Hardware Trojans: extended version."
J. Cryptographic Engineering, vol. 4, pp. 19-31, Springer, 2014.
https://doi.org/10.1007/s13389-013-0068-0


[[ChMaGa16]][ChMaGa16]
S. Checkoway, J. Maskiewicz, C. Garman, J. Friedm, S. Cohneym, M. Green,
N. Heninger, R. Weinmann, E. Rescorla, and H. Shacham,
"A Systematic Analysis of the Juniper Dual EC Incident."
ACM CCS 2016, pp. 468-479, ACM, 2016.
https://doi.org/10.1145/2976749.2978395

[[Co99]][Co99]
J. S. Coron,
"On the Security of Random Sources."
PKC 1999, LNCS 1560, Springer, pp. 29-42, 1999.
https://doi.org/10.1007/3-540-49162-7_3

[[CoKwPa20]][CoKwPa20]
S. Cohney, A. Kwong, S. Paz, D. Genkin, N. Heninger, E. Ronen, and Y Yarom,
"Pseudorandom Black Swans: Cache Attacks on CTR_DRBG."
IEEE S&P 2020, Vol 1, pp. 875-892, 2020.
https://doi.ieeecomputersociety.org/10.1109/SP40000.2020.00046

[[HaKoMa12]][HaKoMa12]
M. Hamburg, P. Kocher, and M. E. Marson,
"Analysis of Intel's Ivy Bridge Digital Random Number Generator."
Technical Report, Cryptography Research (Prepared for Intel), March 2012.

[[HoSh20]][HoSh20]
V. T. Hoang and Y. Shen,
"Security Analysis of NIST CTR-DRBG."
CRYPTO 2020, To appear, 2020.
https://eprint.iacr.org/2020/619

[[KaScVe13]][KaScVe13]
D. Karaklajić, J.-M. Schmidt, and I. Verbauwhede,
"Hardware Designer's Guide to Fault Attacks."
IEEE Transactions on Very Large Scale Integration (VLSI) Systems,
vol. 21, no. 12, pp. 2295-2306, Dec. 2013,
https://doi.org/10.1109/TVLSI.2012.2231707

[[LiBaBo13]][LiBaBo13]
J. S. Liberty, A. Barrera, D. W. Boerstler, T. B. Chadwick, S. R. Cottier, H. P. Hofstee, J. A. Rosser, and  M. L. Tsai,
"True hardware random number generation implemented in the 32-nm SOI POWER7+ processor."
IBM J. of Res. and Dev., vol. 57, no. 6, pp. 4:1-4:7, Nov.-Dec. 2013.
https://doi.org/10.1147/JRD.2013.2279599

[[MaMo09]][MaMo09]
A. T. Markettos and S. W. Moore, "The Frequency Injection Attack on
Ring-Oscillator-Based True Random Number Generators."
CHES 2009, LNCS 5747, Springer, pp. 317-331, 2009.
https://doi.org/10.1007/978-3-642-04138-9_23

[[Me18]][Me18]
J. P. Mechalas,
"Intel Digital Random Number Generator (DRNG): Software Implementation Guide."
Revision 2.1. Intel Technical Report, October 2018.
https://software.intel.com/content/www/us/en/develop/articles/intel-digital-random-number-generator-drng-software-implementation-guide.html

[[RaSt98]][RaSt98]
M. Raab and A. Steger,
"“Balls into Bins” — A Simple and Tight Analysis."
RANDOM 1998, LNCS 1518, Springer, pp. 159-170, 1999.
https://doi.org/10.1007/3-540-49543-6_13

[[RaMiRa21]][RaMiRa21]
H. Ragab, A. Milburn, K. Razavi, H. Bos, and C. Giuffrida,
"CrossTalk : Speculative Data Leaks Across Cores Are Real."
To appear at IEEE S&P 2021.
https://download.vusec.net/papers/crosstalk_sp21.pdf

[[ScKi02]][ScKi02]
W. Schindler and W. Killmann,
"Evaluation Criteria for True (Physical) Random Number Generators Used in
Cryptographic Applications."
CHES 2002, LNCS 2523, Springer, pp. 431-449, 2002.
https://doi.org/10.1007/3-540-36400-5_31

[[ShTe15]][ShTe15]
T. Shrimpton and R. S. Terashima,
"A Provable-Security Analysis of Intel’s Secure Key RNG."
EUROCRYPT 2015, LNVS 9056, Springer, pp. 77-100, 2015.
https://doi.org/10.1007/978-3-662-46800-5_4

[[WoSh19]][WoSh19]
J. Woodage and D. Shumov,
"An Analysis of NIST SP 800-90A."
EUROCRYPT 2019, LNCS 11477, pp. 151-180, 2019.
https://eprint.iacr.org/2018/349
https://doi.org/10.1007/978-3-030-17656-3_6

