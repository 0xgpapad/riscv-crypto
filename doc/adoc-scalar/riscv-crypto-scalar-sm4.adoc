[[crypto_scalar_sm4]]
=== Scalar SM4 Instructions

Synopsis::
Lightweight instructions for accelerating the SM4 block cipher.

Mnemonic::

----
sm4ed     rt, rs2, bs
sm4ks     rt, rs2, bs
----

Encoding::
[wavedrom, , svg]
----
{reg:[
    {bits: 32, name:todo,attr:["todo"]}
]}
----

Description::
This section proposes acceleration instructions for
the SM4 block cipher cite:[block:sm4:1, ietf:sm4].
The instructions are taken from proposals found in cite:[MJS:LWAES:20].
They are very lightweight and require only a single SBox instance.
They are designed to give a very high performance improvement with
minimal area requirements, and resemble a TTables-esq
software implementation.

* `sm4ed` - Encrypt/Decrypt. Applies the SBox and `L` transformations as part of the round function.
* `sm4ks` - KeySchedule. Applies the SBox and `L'` transformations as part of the KeySchedule.

.Architecture Note
[NOTE,caption="SH"]
====
The instructions source their destination register from
bits `19:15` of the encoding, rather than the usual `11:7`.
This is because the instructions are designed to be used such that
the destination register is always the same as `rs1`.
See Appendix <<crypto_scalar_encodings>> for more information.
*This is expected to change* in a future release to maintain
consistency with the base ISA.
====

.Supporting Material
[NOTE,caption="SH"]
====
These instrucitons were derived from work in cite:[MJS:LWAES:20].
====

Operation::
[source,sail]
--
function clause execute (SM4ED(bs, rs2, rt)) = {
  let shamt : bits(6)  = (0b0 @ bs @ 0b000); /* shamt = bs*8 */
  let sb_in : bits(8)  = (X(rs2) >> shamt)[7..0];
  let x     : bits(32) = 0x000000 @ sm4_sbox(sb_in);
  let y     : bits(32) = x ^ (x               <<  8) ^ ( x               <<  2) ^
                             (x               << 18) ^ ((x & 0x0000003F) << 26) ^
                             ((x & 0x000000C0) << 10);
  let z     : bits(32) = (y << shamt) ^ (y >> (0b100000 - shamt));
  let result: bits(32) = z ^ X(rt)[31..0];
  X(rt)                = EXTZ(result);
  RETIRE_SUCCESS
}

function clause execute (SM4KS(bs,rs2,rt)) = {
  let shamt : bits(6)  = (0b0 @ bs @ 0b000); /* shamt = bs*8 */
  let sb_in : bits(8)  = (X(rs2) >> shamt)[7..0];
  let x     : bits(32) = 0x000000 @ sm4_sbox(sb_in);
  let y     : bits(32) = x ^ ((x & 0x00000007) << 29) ^ ((x & 0x000000FE) <<  7) ^
                             ((x & 0x00000001) << 23) ^ ((x & 0x000000F8) << 13) ;
  let z     : bits(32) = (y << shamt) ^ (y >> (0b100000 - shamt));
  let result: bits(32) = z ^ X(rt)[31..0];
  X(rt) = EXTZ(result);
  RETIRE_SUCCESS
}
--

