[[crypto_scalar_aes]]
=== Scalar AES Instructions


Synopsis::
Lightweight AES instructions for RV32.

Mnemonic::

----
aes32esi     rt, rs2, bs // Encrypt: SubBytes
aes32esmi    rt, rs2, bs // Encrypt: SubBytes & MixColumns
aes32dsi     rt, rs2, bs // Decrypt: SubBytes
aes32dsmi    rt, rs2, bs // Decrypt: SubBytes & MixColumns
----

Encoding::
[wavedrom, , svg]
----
{reg:[
    {bits: 32, name:todo,attr:["todo"]}
]}
----

Description::
These instructions are a very lightweight way to accelerate the
AES block cipher.
They are designed to enable a partial T-Table based implementation
of AES in hardware, where the SubBytes, ShiftRows and MixColumns
transformations are all rolled into a single instruction, with the
per-byte results then accumulated.
The `bs` immediate operand is a 2-bit _Byte Select_, and indicates
which byte of the input word is operated on.

.Architecture Note
[NOTE,caption="SH"]
====
The instructions source their destination register from
bits `19:15` of the encoding, rather than the usual `11:7`.
This is because the instructions are designed to be used such that
the destination register is always the same as `rs1`.
See Appendix <<crypto_scalar_encodings>> for more information.
*This is expected to change* in a future release to maintain
consistency with the base ISA.
====

.Note To Software Developers
[NOTE,caption="SH"]
====
These instructions use the Equivalent Inverse Cipher
representaiton cite:[nist:fips:197] (Section 5.3.5) of AES.
This affects the computation of the KeySchedule, as shown in
cite:[nist:fips:197] (Figure 15).
====

.Supporting Material
[NOTE,caption="SH"]
====
These instrucitons were derived from work in cite:[MJS:LWAES:20].
Supporting material, including rationale and a design space exploration
for these instructions can be found in cite:[cryptoeprint:2020:930].
====

Operation::
[source,sail]
--
function clause execute (AES32(bs, rs2, rt, op))={
  let rs1_val : xlenbits = X(rt);
  let rs2_val : xlenbits = X(rs2);
  let shamt   : bits(6)  = (0b0 @ bs @ 0b000); /* shamt = bs*8 */
  let si      : bits(8)  = (rs2_val >> shamt)[7..0]; /* SBox Input */
  let so      : bits(8)  = if aes_op_fwd(op) then aes_sbox_fwd(si)
                                               else aes_sbox_inv(si);
  let mixed   : xlenbits =
    if aes_op_does_mix(op)  then
      if aes_op_fwd(op) then aes_mixcolumn_byte_fwd(so)
                        else aes_mixcolumn_byte_inv(so)
    else
      0x000000 @ so;
  let result : xlenbits = rs1_val ^ (mixed << shamt) ^ (mixed >> (0b100000 - shamt));
  X(rt) = result;
  RETIRE_SUCCESS
}
--
