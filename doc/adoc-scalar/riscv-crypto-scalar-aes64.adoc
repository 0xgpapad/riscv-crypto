[[crypto_scalar_aes64]]
=== Scalar AES Instructions (RV64)


Synopsis::
Lightweight AES instructions for RV64.

Mnemonic::

----
aes64ks1i  rd, rs1, rcon // KeySchedule: SubBytes, Rotate, Round Const
aes64ks2   rd, rs1, rs2  // KeySchedule: XOR summation
aes64im    rd, rs1       // KeySchedule: InvMixColumns for Decrypt
aes64esm   rd, rs1, rs2  // Round:    ShiftRows,    SubBytes,    MixColumns
aes64es    rd, rs1, rs2  // Round:    ShiftRows,    SubBytes
aes64dsm   rd, rs1, rs2  // Round: InvShiftRows, InvSubBytes, InvMixColumns
aes64ds    rd, rs1, rs2  // Round: InvShiftRows, InvSubBytes
----

Encoding `aes64ks1i`::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x13},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x1},
{bits: 5, name: 'rs1'},
{bits: 4, name: 'rcon'},
{bits: 1, name: 0x1},
{bits: 5, name: 0x18},
{bits: 2, name: 0x0},
]}
....
Encoding `aes64im`::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x13},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x1},
{bits: 5, name: 'rs1'},
{bits: 5, name: 0x0},
{bits: 5, name: 0x18},
{bits: 2, name: 0x0},
]}
....
Encoding `aes64ks2`::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x33},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x0},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 5, name: 0x1f},
{bits: 2, name: 0x1},
]}
....
Encoding `aes64esm`::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x33},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x0},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 5, name: 0x1b},
{bits: 2, name: 0x0},
]}
....
Encoding `aes64es`::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x33},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x0},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 5, name: 0x19},
{bits: 2, name: 0x0},
]}
....
Encoding `aes64dsm`::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x33},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x0},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 5, name: 0x1f},
{bits: 2, name: 0x0},
]}
....
Encoding `aes64ds`::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x33},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x0},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 5, name: 0x1d},
{bits: 2, name: 0x0},
]}
....

Description::
These instructions accelerate
the SubBytes, ShiftRows and MixColumns transformations of AES.
Each round instruction takes two 64-bit registers as input, representing
the 128-bit state of the AES cipher, and outputs one 64-bit
result, i.e. half of the next round state.

* The
  `aes64ks1i` / `aes64ks2`
  instructions are used in the encrypt KeySchedule.
  `aes64ks1i` implements the rotation, SubBytes and Round Constant
  addition steps.
  `aes64ks2` implements the remaining `xor` operations.
  
* The `aes64im`
  instruction applies the inverse MixColumns
  transformation to two columns of the state array, packed into a single
  64-bit register.
  It is used to create the inverse cipher KeySchedule, according to
  the equivalent inverse cipher construction in
  cite:[nist:fips:197] (Page 23, Section 5.3.5).
  
* The `aes64esm` / `aes64dsm` instructions perform the
  (Inverse) SubBytes, ShiftRows and MixColumns Transformations.
  
* The `aes64es` / `aes64ds` instructions perform the
  (Inverse) SubBytes and ShiftRows Transformations.
  They are used for the last round only.
  
* Computing the next round state uses two instructions.
  The high or low 8 bytes of the next state are selected by swapping the order
  of the source registers.

.Note To Software Developers
[NOTE,caption="SH"]
====
The following code snippet shows one middle round of the AES block encryption.
`t0` and `t1` hold the current round state.
`t2` and `t3` hold the next round state.

  aes64esm t2, t0, t1 // ShiftRows, SubBytes, MixColumns bytes 0..7
  aes64esm t3, t1, t0 // "          "         "          "     8..15

====

.Note To Software Developers
[NOTE,caption="SH"]
====
Unlike the 32-bit AES instructions, the 64-bit variants _do not_ use the
Equivalent Inverse Cipher construction cite:[nist:fips:197] (Section 5.3.5).
====

.Supporting Material
[NOTE,caption="SH"]
====
Supporting material, including rationale and a design space exploration
for these instructions can be found in cite:[cryptoeprint:2020:930].
====

Operation::
[source,sail]
--
function crypto_aes64(rd, rs1, rs2, enc, mix) = {
  let sr : bits(64) = match enc {
    true  => aes_rv64_shiftrows_fwd(X(rs2)[63..0], X(rs1)[63..0]), /*Encrypt*/
    false => aes_rv64_shiftrows_inv(X(rs2)[63..0], X(rs1)[63..0])  /*Decrypt*/
  };
  let wd : bits(64) = sr[63..0];
  let sb : bits(64) = match enc {
    true  => aes_apply_fwd_sbox_to_each_byte(wd), /* Encrypt */
    false => aes_apply_inv_sbox_to_each_byte(wd)  /* Decrypt */
  };
  X(rd)  = match (mix, enc) {
    (true, true ) => aes_mixcolumn_fwd(sb[63..32]) @ aes_mixcolumn_fwd(sb[31..0]),
    (true, false) => aes_mixcolumn_inv(sb[63..32]) @ aes_mixcolumn_inv(sb[31..0]),
    (false,  _  ) => sb
  };
  RETIRE_SUCCESS
}

function clause execute (AES64KS1I(rcon, rs1, rd)) = {
  let tmp1 : bits(32) = X(rs1)[63..32];
  let rc   : bits(32) = aes_decode_rcon(rcon);
  let tmp2 : bits(32) = if (rcon ==0xA) then tmp1 else ror32(tmp1, 8);
  let tmp3 : bits(32) = aes_sbox_fwd(tmp2[31..24]) @ aes_sbox_fwd(tmp2[23..16]) @
                         aes_sbox_fwd(tmp2[15.. 8]) @ aes_sbox_fwd(tmp2[ 7.. 0]) ;
  let result : bits(64) = (tmp3 ^ rc) @ (tmp3 ^ rc);
  X(rd) = EXTZ(result);
  RETIRE_SUCCESS
}

function clause execute (AES64KS2(rs2, rs1, rd)) = {
  let w0 : bits(32) = X(rs1)[63..32] ^ X(rs2)[31..0];
  let w1 : bits(32) = X(rs1)[63..32] ^ X(rs2)[31..0] ^ X(rs2)[63..32];
  X(rd)  = w1 @ w0;
  RETIRE_SUCCESS
}

function clause execute (AES64IM(rs1, rd)) = {
  let w0 : bits(32) = aes_mixcolumn_inv(X(rs1)[31.. 0]);
  let w1 : bits(32) = aes_mixcolumn_inv(X(rs1)[63..32]);
  X(rd)  = w1 @ w0;
  RETIRE_SUCCESS
}
--
